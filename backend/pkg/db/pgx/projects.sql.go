// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package pgdb

import (
	"context"
	"database/sql"

	"github.com/jackc/pgx/v5/pgtype"
)

const addFileToProject = `-- name: AddFileToProject :one
INSERT INTO project_files (project_id, name, file_key)
VALUES ($1, $2, $3) RETURNING id, project_id, name, file_key, deleted, token_count, metadata, created_at, updated_at
`

type AddFileToProjectParams struct {
	ProjectID int64  `json:"project_id"`
	Name      string `json:"name"`
	FileKey   string `json:"file_key"`
}

func (q *Queries) AddFileToProject(ctx context.Context, arg AddFileToProjectParams) (ProjectFile, error) {
	row := q.db.QueryRow(ctx, addFileToProject, arg.ProjectID, arg.Name, arg.FileKey)
	var i ProjectFile
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.FileKey,
		&i.Deleted,
		&i.TokenCount,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const addProjectUpdate = `-- name: AddProjectUpdate :exec
INSERT INTO project_updates (project_id, update_type, update_message)
VALUES ($1, $2, $3)
`

type AddProjectUpdateParams struct {
	ProjectID     int64  `json:"project_id"`
	UpdateType    string `json:"update_type"`
	UpdateMessage []byte `json:"update_message"`
}

func (q *Queries) AddProjectUpdate(ctx context.Context, arg AddProjectUpdateParams) error {
	_, err := q.db.Exec(ctx, addProjectUpdate, arg.ProjectID, arg.UpdateType, arg.UpdateMessage)
	return err
}

const addTokenCountToFile = `-- name: AddTokenCountToFile :exec
UPDATE project_files SET token_count = $2 WHERE id = $1
`

type AddTokenCountToFileParams struct {
	ID         int64 `json:"id"`
	TokenCount int32 `json:"token_count"`
}

func (q *Queries) AddTokenCountToFile(ctx context.Context, arg AddTokenCountToFileParams) error {
	_, err := q.db.Exec(ctx, addTokenCountToFile, arg.ID, arg.TokenCount)
	return err
}

const createProject = `-- name: CreateProject :one
INSERT INTO graphs (group_id, name, state)
VALUES ($1, $2, $3) RETURNING id, group_id, user_id, graph_id, name, description, state, type, hidden, created_at, updated_at
`

type CreateProjectParams struct {
	GroupID sql.NullInt64 `json:"group_id"`
	Name    string        `json:"name"`
	State   string        `json:"state"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Graph, error) {
	row := q.db.QueryRow(ctx, createProject, arg.GroupID, arg.Name, arg.State)
	var i Graph
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.GraphID,
		&i.Name,
		&i.Description,
		&i.State,
		&i.Type,
		&i.Hidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectWithOwner = `-- name: CreateProjectWithOwner :one
INSERT INTO graphs (group_id, user_id, graph_id, name, description, state, type, hidden)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, group_id, user_id, graph_id, name, description, state, type, hidden, created_at, updated_at
`

type CreateProjectWithOwnerParams struct {
	GroupID     sql.NullInt64 `json:"group_id"`
	UserID      sql.NullInt64 `json:"user_id"`
	GraphID     sql.NullInt64 `json:"graph_id"`
	Name        string        `json:"name"`
	Description pgtype.Text   `json:"description"`
	State       string        `json:"state"`
	Type        pgtype.Text   `json:"type"`
	Hidden      bool          `json:"hidden"`
}

func (q *Queries) CreateProjectWithOwner(ctx context.Context, arg CreateProjectWithOwnerParams) (Graph, error) {
	row := q.db.QueryRow(ctx, createProjectWithOwner,
		arg.GroupID,
		arg.UserID,
		arg.GraphID,
		arg.Name,
		arg.Description,
		arg.State,
		arg.Type,
		arg.Hidden,
	)
	var i Graph
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.GraphID,
		&i.Name,
		&i.Description,
		&i.State,
		&i.Type,
		&i.Hidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM graphs WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteProjectFile = `-- name: DeleteProjectFile :exec
DELETE FROM project_files WHERE id = $1
`

func (q *Queries) DeleteProjectFile(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProjectFile, id)
	return err
}

const getAllProjectsWithGroups = `-- name: GetAllProjectsWithGroups :many
SELECT
    grp.id AS group_id,
    grp.name AS group_name,
    g.id AS project_id,
    g.name AS project_name,
    g.state AS project_state,
    g.hidden,
    COALESCE(g.type, '') AS project_type,
    'admin'::TEXT AS role
FROM groups AS grp
JOIN graphs AS g ON g.group_id = grp.id
ORDER BY grp.id, g.id
`

type GetAllProjectsWithGroupsRow struct {
	GroupID      int64  `json:"group_id"`
	GroupName    string `json:"group_name"`
	ProjectID    int64  `json:"project_id"`
	ProjectName  string `json:"project_name"`
	ProjectState string `json:"project_state"`
	Hidden       bool   `json:"hidden"`
	ProjectType  string `json:"project_type"`
	Role         string `json:"role"`
}

func (q *Queries) GetAllProjectsWithGroups(ctx context.Context) ([]GetAllProjectsWithGroupsRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectsWithGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProjectsWithGroupsRow{}
	for rows.Next() {
		var i GetAllProjectsWithGroupsRow
		if err := rows.Scan(
			&i.GroupID,
			&i.GroupName,
			&i.ProjectID,
			&i.ProjectName,
			&i.ProjectState,
			&i.Hidden,
			&i.ProjectType,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedProjectFiles = `-- name: GetDeletedProjectFiles :many
SELECT id, project_id, name, file_key, deleted, token_count, metadata, created_at, updated_at FROM project_files WHERE project_id = $1 AND deleted = true
`

func (q *Queries) GetDeletedProjectFiles(ctx context.Context, projectID int64) ([]ProjectFile, error) {
	rows, err := q.db.Query(ctx, getDeletedProjectFiles, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectFile{}
	for rows.Next() {
		var i ProjectFile
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.FileKey,
			&i.Deleted,
			&i.TokenCount,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, group_id, user_id, graph_id, name, description, state, type, hidden, created_at, updated_at FROM graphs WHERE id = $1
`

func (q *Queries) GetProjectByID(ctx context.Context, id int64) (Graph, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i Graph
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.GraphID,
		&i.Name,
		&i.Description,
		&i.State,
		&i.Type,
		&i.Hidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectFileByKey = `-- name: GetProjectFileByKey :one
SELECT id, project_id, name, file_key, deleted, token_count, metadata, created_at, updated_at
FROM project_files
WHERE project_id = $1
  AND file_key = $2
  AND deleted = FALSE
`

type GetProjectFileByKeyParams struct {
	ProjectID int64  `json:"project_id"`
	FileKey   string `json:"file_key"`
}

func (q *Queries) GetProjectFileByKey(ctx context.Context, arg GetProjectFileByKeyParams) (ProjectFile, error) {
	row := q.db.QueryRow(ctx, getProjectFileByKey, arg.ProjectID, arg.FileKey)
	var i ProjectFile
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.FileKey,
		&i.Deleted,
		&i.TokenCount,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectFiles = `-- name: GetProjectFiles :many
SELECT id, project_id, name, file_key, deleted, token_count, metadata, created_at, updated_at FROM project_files WHERE project_id = $1
`

func (q *Queries) GetProjectFiles(ctx context.Context, projectID int64) ([]ProjectFile, error) {
	rows, err := q.db.Query(ctx, getProjectFiles, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectFile{}
	for rows.Next() {
		var i ProjectFile
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.FileKey,
			&i.Deleted,
			&i.TokenCount,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectIDsForFiles = `-- name: GetProjectIDsForFiles :many
SELECT DISTINCT project_id
FROM project_files
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetProjectIDsForFiles(ctx context.Context, fileIds []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getProjectIDsForFiles, fileIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var project_id int64
		if err := rows.Scan(&project_id); err != nil {
			return nil, err
		}
		items = append(items, project_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectSystemPrompts = `-- name: GetProjectSystemPrompts :many
SELECT id, project_id, prompt, created_at, updated_at FROM project_system_prompts WHERE project_id = $1
`

func (q *Queries) GetProjectSystemPrompts(ctx context.Context, projectID int64) ([]ProjectSystemPrompt, error) {
	rows, err := q.db.Query(ctx, getProjectSystemPrompts, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectSystemPrompt{}
	for rows.Next() {
		var i ProjectSystemPrompt
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Prompt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByGroup = `-- name: GetProjectsByGroup :many
SELECT DISTINCT g.id, g.group_id, g.user_id, g.graph_id, g.name, g.description, g.state, g.type, g.hidden, g.created_at, g.updated_at
FROM graphs AS g
LEFT JOIN graphs AS parent ON g.graph_id = parent.id
WHERE g.group_id = $1
   OR parent.group_id = $1
`

func (q *Queries) GetProjectsByGroup(ctx context.Context, groupID sql.NullInt64) ([]Graph, error) {
	rows, err := q.db.Query(ctx, getProjectsByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Graph{}
	for rows.Next() {
		var i Graph
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.UserID,
			&i.GraphID,
			&i.Name,
			&i.Description,
			&i.State,
			&i.Type,
			&i.Hidden,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsForUser = `-- name: GetProjectsForUser :many
SELECT
    grp.id AS group_id,
    grp.name AS group_name,
    g.id AS project_id,
    g.name AS project_name,
    g.state AS project_state,
    g.hidden,
    COALESCE(g.type, '') AS project_type,
    gu.role as role
FROM groups AS grp
JOIN graphs AS g
    ON g.group_id = grp.id
JOIN group_users AS gu
    ON gu.group_id = grp.id
WHERE gu.user_id = $1
  AND COALESCE(g.type, '') <> 'expert'
  AND g.hidden = FALSE
ORDER BY grp.id, g.id
`

type GetProjectsForUserRow struct {
	GroupID      int64  `json:"group_id"`
	GroupName    string `json:"group_name"`
	ProjectID    int64  `json:"project_id"`
	ProjectName  string `json:"project_name"`
	ProjectState string `json:"project_state"`
	Hidden       bool   `json:"hidden"`
	ProjectType  string `json:"project_type"`
	Role         string `json:"role"`
}

func (q *Queries) GetProjectsForUser(ctx context.Context, userID int64) ([]GetProjectsForUserRow, error) {
	rows, err := q.db.Query(ctx, getProjectsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectsForUserRow{}
	for rows.Next() {
		var i GetProjectsForUserRow
		if err := rows.Scan(
			&i.GroupID,
			&i.GroupName,
			&i.ProjectID,
			&i.ProjectName,
			&i.ProjectState,
			&i.Hidden,
			&i.ProjectType,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenCountsOfFiles = `-- name: GetTokenCountsOfFiles :many
SELECT id, token_count
FROM project_files
WHERE id = ANY($1::bigint[])
`

type GetTokenCountsOfFilesRow struct {
	ID         int64 `json:"id"`
	TokenCount int32 `json:"token_count"`
}

func (q *Queries) GetTokenCountsOfFiles(ctx context.Context, dollar_1 []int64) ([]GetTokenCountsOfFilesRow, error) {
	rows, err := q.db.Query(ctx, getTokenCountsOfFiles, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTokenCountsOfFilesRow{}
	for rows.Next() {
		var i GetTokenCountsOfFilesRow
		if err := rows.Scan(&i.ID, &i.TokenCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProjects = `-- name: GetUserProjects :many
SELECT
    g.id AS project_id,
    g.name AS project_name,
    g.state AS project_state,
    g.hidden,
    COALESCE(g.type, '') AS project_type
FROM graphs AS g
WHERE g.user_id = $1
ORDER BY g.id
`

type GetUserProjectsRow struct {
	ProjectID    int64  `json:"project_id"`
	ProjectName  string `json:"project_name"`
	ProjectState string `json:"project_state"`
	Hidden       bool   `json:"hidden"`
	ProjectType  string `json:"project_type"`
}

func (q *Queries) GetUserProjects(ctx context.Context, userID sql.NullInt64) ([]GetUserProjectsRow, error) {
	rows, err := q.db.Query(ctx, getUserProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserProjectsRow{}
	for rows.Next() {
		var i GetUserProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.ProjectName,
			&i.ProjectState,
			&i.Hidden,
			&i.ProjectType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserInProject = `-- name: IsUserInProject :one
SELECT
    COUNT(*) AS count
FROM graphs AS g
WHERE g.id = $1::bigint
  AND (
    g.user_id = $2::bigint
    OR (
      g.group_id IS NOT NULL
      AND EXISTS (
        SELECT 1
        FROM group_users AS gu
        WHERE gu.group_id = g.group_id
          AND gu.user_id = $2::bigint
      )
    )
    OR (
      g.graph_id IS NOT NULL
      AND EXISTS (
        SELECT 1
        FROM graphs AS parent
        WHERE parent.id = g.graph_id
          AND (
            parent.user_id = $2::bigint
            OR (
              parent.group_id IS NOT NULL
              AND EXISTS (
                SELECT 1
                FROM group_users AS parent_gu
                WHERE parent_gu.group_id = parent.group_id
                  AND parent_gu.user_id = $2::bigint
              )
            )
          )
      )
    )
    OR (g.user_id IS NULL AND g.group_id IS NULL AND g.graph_id IS NULL)
  )
`

type IsUserInProjectParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) IsUserInProject(ctx context.Context, arg IsUserInProjectParams) (int64, error) {
	row := q.db.QueryRow(ctx, isUserInProject, arg.ID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const markProjectFileAsDeleted = `-- name: MarkProjectFileAsDeleted :exec
UPDATE project_files 
SET deleted = true 
WHERE project_id = $1 AND file_key = $2
`

type MarkProjectFileAsDeletedParams struct {
	ProjectID int64  `json:"project_id"`
	FileKey   string `json:"file_key"`
}

func (q *Queries) MarkProjectFileAsDeleted(ctx context.Context, arg MarkProjectFileAsDeletedParams) error {
	_, err := q.db.Exec(ctx, markProjectFileAsDeleted, arg.ProjectID, arg.FileKey)
	return err
}

const updateProject = `-- name: UpdateProject :one
UPDATE graphs SET name = $2 WHERE id = $1 RETURNING id, group_id, user_id, graph_id, name, description, state, type, hidden, created_at, updated_at
`

type UpdateProjectParams struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Graph, error) {
	row := q.db.QueryRow(ctx, updateProject, arg.ID, arg.Name)
	var i Graph
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.GraphID,
		&i.Name,
		&i.Description,
		&i.State,
		&i.Type,
		&i.Hidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectFileMetadata = `-- name: UpdateProjectFileMetadata :exec
UPDATE project_files SET metadata = $2, updated_at = NOW() WHERE id = $1
`

type UpdateProjectFileMetadataParams struct {
	ID       int64       `json:"id"`
	Metadata pgtype.Text `json:"metadata"`
}

func (q *Queries) UpdateProjectFileMetadata(ctx context.Context, arg UpdateProjectFileMetadataParams) error {
	_, err := q.db.Exec(ctx, updateProjectFileMetadata, arg.ID, arg.Metadata)
	return err
}

const updateProjectState = `-- name: UpdateProjectState :one
UPDATE graphs SET state = $2 WHERE id = $1 RETURNING id, group_id, user_id, graph_id, name, description, state, type, hidden, created_at, updated_at
`

type UpdateProjectStateParams struct {
	ID    int64  `json:"id"`
	State string `json:"state"`
}

func (q *Queries) UpdateProjectState(ctx context.Context, arg UpdateProjectStateParams) (Graph, error) {
	row := q.db.QueryRow(ctx, updateProjectState, arg.ID, arg.State)
	var i Graph
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.UserID,
		&i.GraphID,
		&i.Name,
		&i.Description,
		&i.State,
		&i.Type,
		&i.Hidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
