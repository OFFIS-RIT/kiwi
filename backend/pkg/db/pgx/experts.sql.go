// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: experts.sql

package pgdb

import (
	"context"
	"database/sql"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAvailableExpertProjects = `-- name: GetAvailableExpertProjects :many
WITH current_graph AS (
    SELECT
        g.id,
        COALESCE(g.group_id, parent.group_id) AS group_id
    FROM graphs AS g
    LEFT JOIN graphs AS parent ON g.graph_id = parent.id
    WHERE g.id = $2::bigint
)
SELECT
    p.id AS project_id,
    p.group_id,
    p.user_id,
    p.graph_id,
    p.name,
    p.description,
    p.state,
    p.hidden,
    p.created_at,
    p.updated_at
FROM graphs AS p
LEFT JOIN graphs AS parent ON p.graph_id = parent.id
LEFT JOIN current_graph AS cg ON TRUE
WHERE p.type = 'expert'
  AND p.state = 'ready'
  AND (
      (cg.group_id IS NOT NULL AND COALESCE(p.group_id, parent.group_id) = cg.group_id)
      OR (p.group_id IS NULL AND p.user_id IS NULL AND p.graph_id IS NULL)
      OR p.user_id = $1::bigint
      OR p.graph_id = $2::bigint
  )
ORDER BY p.id ASC
`

type GetAvailableExpertProjectsParams struct {
	UserID           int64 `json:"user_id"`
	CurrentProjectID int64 `json:"current_project_id"`
}

type GetAvailableExpertProjectsRow struct {
	ProjectID   int64              `json:"project_id"`
	GroupID     sql.NullInt64      `json:"group_id"`
	UserID      sql.NullInt64      `json:"user_id"`
	GraphID     sql.NullInt64      `json:"graph_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	State       string             `json:"state"`
	Hidden      bool               `json:"hidden"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetAvailableExpertProjects(ctx context.Context, arg GetAvailableExpertProjectsParams) ([]GetAvailableExpertProjectsRow, error) {
	rows, err := q.db.Query(ctx, getAvailableExpertProjects, arg.UserID, arg.CurrentProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableExpertProjectsRow{}
	for rows.Next() {
		var i GetAvailableExpertProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.GroupID,
			&i.UserID,
			&i.GraphID,
			&i.Name,
			&i.Description,
			&i.State,
			&i.Hidden,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpertProjectByProjectID = `-- name: GetExpertProjectByProjectID :one
SELECT
    g.id AS project_id,
    g.group_id,
    g.user_id,
    g.graph_id,
    g.name,
    g.description,
    g.state,
    COALESCE(g.type, '') AS project_type,
    g.hidden,
    g.created_at,
    g.updated_at
FROM graphs AS g
WHERE g.type = 'expert'
  AND g.id = $1
`

type GetExpertProjectByProjectIDRow struct {
	ProjectID   int64              `json:"project_id"`
	GroupID     sql.NullInt64      `json:"group_id"`
	UserID      sql.NullInt64      `json:"user_id"`
	GraphID     sql.NullInt64      `json:"graph_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	State       string             `json:"state"`
	ProjectType string             `json:"project_type"`
	Hidden      bool               `json:"hidden"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetExpertProjectByProjectID(ctx context.Context, id int64) (GetExpertProjectByProjectIDRow, error) {
	row := q.db.QueryRow(ctx, getExpertProjectByProjectID, id)
	var i GetExpertProjectByProjectIDRow
	err := row.Scan(
		&i.ProjectID,
		&i.GroupID,
		&i.UserID,
		&i.GraphID,
		&i.Name,
		&i.Description,
		&i.State,
		&i.ProjectType,
		&i.Hidden,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExpertProjects = `-- name: GetExpertProjects :many
SELECT
    g.id AS project_id,
    g.group_id,
    g.user_id,
    g.graph_id,
    g.name,
    g.description,
    g.state,
    COALESCE(g.type, '') AS project_type,
    g.hidden,
    g.created_at,
    g.updated_at
FROM graphs AS g
WHERE g.type = 'expert'
ORDER BY g.id ASC
`

type GetExpertProjectsRow struct {
	ProjectID   int64              `json:"project_id"`
	GroupID     sql.NullInt64      `json:"group_id"`
	UserID      sql.NullInt64      `json:"user_id"`
	GraphID     sql.NullInt64      `json:"graph_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	State       string             `json:"state"`
	ProjectType string             `json:"project_type"`
	Hidden      bool               `json:"hidden"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetExpertProjects(ctx context.Context) ([]GetExpertProjectsRow, error) {
	rows, err := q.db.Query(ctx, getExpertProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpertProjectsRow{}
	for rows.Next() {
		var i GetExpertProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.GroupID,
			&i.UserID,
			&i.GraphID,
			&i.Name,
			&i.Description,
			&i.State,
			&i.ProjectType,
			&i.Hidden,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
