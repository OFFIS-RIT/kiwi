// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: relationships.sql

package pgdb

import (
	"context"

	"github.com/pgvector/pgvector-go"
)

const deleteProjectRelationship = `-- name: DeleteProjectRelationship :exec
DELETE FROM relationships WHERE id = $1
`

func (q *Queries) DeleteProjectRelationship(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProjectRelationship, id)
	return err
}

const deleteRelationshipsWithoutSources = `-- name: DeleteRelationshipsWithoutSources :exec
DELETE FROM relationships 
WHERE project_id = $1 
  AND id NOT IN (SELECT DISTINCT relationship_id FROM relationship_sources)
`

func (q *Queries) DeleteRelationshipsWithoutSources(ctx context.Context, projectID int64) error {
	_, err := q.db.Exec(ctx, deleteRelationshipsWithoutSources, projectID)
	return err
}

const findDuplicateRelationships = `-- name: FindDuplicateRelationships :many
SELECT r1.id as id1, r1.public_id as public_id1, r1.rank as rank1,
       r2.id as id2, r2.public_id as public_id2, r2.rank as rank2,
       r1.source_id, r1.target_id
FROM relationships r1
JOIN relationships r2 ON (
    (r1.source_id = r2.source_id AND r1.target_id = r2.target_id)
    OR (r1.source_id = r2.target_id AND r1.target_id = r2.source_id)
)
WHERE r1.id < r2.id AND r1.project_id = $1
`

type FindDuplicateRelationshipsRow struct {
	Id1       int64   `json:"id1"`
	PublicId1 string  `json:"public_id1"`
	Rank1     float64 `json:"rank1"`
	Id2       int64   `json:"id2"`
	PublicId2 string  `json:"public_id2"`
	Rank2     float64 `json:"rank2"`
	SourceID  int64   `json:"source_id"`
	TargetID  int64   `json:"target_id"`
}

func (q *Queries) FindDuplicateRelationships(ctx context.Context, projectID int64) ([]FindDuplicateRelationshipsRow, error) {
	rows, err := q.db.Query(ctx, findDuplicateRelationships, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindDuplicateRelationshipsRow{}
	for rows.Next() {
		var i FindDuplicateRelationshipsRow
		if err := rows.Scan(
			&i.Id1,
			&i.PublicId1,
			&i.Rank1,
			&i.Id2,
			&i.PublicId2,
			&i.Rank2,
			&i.SourceID,
			&i.TargetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectRelationships = `-- name: GetProjectRelationships :many
SELECT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank FROM relationships r WHERE r.project_id = $1
`

type GetProjectRelationshipsRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetProjectRelationships(ctx context.Context, projectID int64) ([]GetProjectRelationshipsRow, error) {
	rows, err := q.db.Query(ctx, getProjectRelationships, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectRelationshipsRow{}
	for rows.Next() {
		var i GetProjectRelationshipsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceID,
			&i.TargetID,
			&i.Description,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectRelationshipsWithEntityNamesByIDs = `-- name: GetProjectRelationshipsWithEntityNamesByIDs :many
SELECT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank,
       se.name AS source_name,
       te.name AS target_name
FROM relationships r
JOIN entities se ON r.source_id = se.id
JOIN entities te ON r.target_id = te.id
WHERE r.id = ANY($1::bigint[])
`

type GetProjectRelationshipsWithEntityNamesByIDsRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
	SourceName  string  `json:"source_name"`
	TargetName  string  `json:"target_name"`
}

func (q *Queries) GetProjectRelationshipsWithEntityNamesByIDs(ctx context.Context, ids []int64) ([]GetProjectRelationshipsWithEntityNamesByIDsRow, error) {
	rows, err := q.db.Query(ctx, getProjectRelationshipsWithEntityNamesByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectRelationshipsWithEntityNamesByIDsRow{}
	for rows.Next() {
		var i GetProjectRelationshipsWithEntityNamesByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceID,
			&i.TargetID,
			&i.Description,
			&i.Rank,
			&i.SourceName,
			&i.TargetName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationshipSourceDescriptionsBatch = `-- name: GetRelationshipSourceDescriptionsBatch :many
SELECT rs.id, rs.description
FROM relationship_sources rs
WHERE rs.relationship_id = $1
  AND rs.id > $2
ORDER BY rs.id
LIMIT $3
`

type GetRelationshipSourceDescriptionsBatchParams struct {
	RelationshipID int64 `json:"relationship_id"`
	ID             int64 `json:"id"`
	Limit          int32 `json:"limit"`
}

type GetRelationshipSourceDescriptionsBatchRow struct {
	ID          int64  `json:"id"`
	Description string `json:"description"`
}

func (q *Queries) GetRelationshipSourceDescriptionsBatch(ctx context.Context, arg GetRelationshipSourceDescriptionsBatchParams) ([]GetRelationshipSourceDescriptionsBatchRow, error) {
	rows, err := q.db.Query(ctx, getRelationshipSourceDescriptionsBatch, arg.RelationshipID, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelationshipSourceDescriptionsBatchRow{}
	for rows.Next() {
		var i GetRelationshipSourceDescriptionsBatchRow
		if err := rows.Scan(&i.ID, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationshipSourceDescriptionsForFilesBatch = `-- name: GetRelationshipSourceDescriptionsForFilesBatch :many
SELECT rs.id, rs.description
FROM relationship_sources rs
JOIN text_units tu ON tu.id = rs.text_unit_id
WHERE rs.relationship_id = $1
  AND tu.project_file_id = ANY($2::bigint[])
  AND rs.id > $3
ORDER BY rs.id
LIMIT $4
`

type GetRelationshipSourceDescriptionsForFilesBatchParams struct {
	RelationshipID int64   `json:"relationship_id"`
	Column2        []int64 `json:"column_2"`
	ID             int64   `json:"id"`
	Limit          int32   `json:"limit"`
}

type GetRelationshipSourceDescriptionsForFilesBatchRow struct {
	ID          int64  `json:"id"`
	Description string `json:"description"`
}

func (q *Queries) GetRelationshipSourceDescriptionsForFilesBatch(ctx context.Context, arg GetRelationshipSourceDescriptionsForFilesBatchParams) ([]GetRelationshipSourceDescriptionsForFilesBatchRow, error) {
	rows, err := q.db.Query(ctx, getRelationshipSourceDescriptionsForFilesBatch,
		arg.RelationshipID,
		arg.Column2,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelationshipSourceDescriptionsForFilesBatchRow{}
	for rows.Next() {
		var i GetRelationshipSourceDescriptionsForFilesBatchRow
		if err := rows.Scan(&i.ID, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationshipsWithSourcesFromFiles = `-- name: GetRelationshipsWithSourcesFromFiles :many
SELECT DISTINCT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank
FROM relationships r
JOIN relationship_sources rs ON rs.relationship_id = r.id
JOIN text_units tu ON tu.id = rs.text_unit_id
WHERE tu.project_file_id = ANY($1::bigint[])
  AND r.project_id = $2
`

type GetRelationshipsWithSourcesFromFilesParams struct {
	Column1   []int64 `json:"column_1"`
	ProjectID int64   `json:"project_id"`
}

type GetRelationshipsWithSourcesFromFilesRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetRelationshipsWithSourcesFromFiles(ctx context.Context, arg GetRelationshipsWithSourcesFromFilesParams) ([]GetRelationshipsWithSourcesFromFilesRow, error) {
	rows, err := q.db.Query(ctx, getRelationshipsWithSourcesFromFiles, arg.Column1, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelationshipsWithSourcesFromFilesRow{}
	for rows.Next() {
		var i GetRelationshipsWithSourcesFromFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceID,
			&i.TargetID,
			&i.Description,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationshipsWithSourcesFromUnits = `-- name: GetRelationshipsWithSourcesFromUnits :many
SELECT DISTINCT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank
FROM relationships r
JOIN relationship_sources rs ON rs.relationship_id = r.id
WHERE rs.text_unit_id = ANY($1::bigint[])
  AND r.project_id = $2
`

type GetRelationshipsWithSourcesFromUnitsParams struct {
	Column1   []int64 `json:"column_1"`
	ProjectID int64   `json:"project_id"`
}

type GetRelationshipsWithSourcesFromUnitsRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetRelationshipsWithSourcesFromUnits(ctx context.Context, arg GetRelationshipsWithSourcesFromUnitsParams) ([]GetRelationshipsWithSourcesFromUnitsRow, error) {
	rows, err := q.db.Query(ctx, getRelationshipsWithSourcesFromUnits, arg.Column1, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelationshipsWithSourcesFromUnitsRow{}
	for rows.Next() {
		var i GetRelationshipsWithSourcesFromUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceID,
			&i.TargetID,
			&i.Description,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transferRelationshipSources = `-- name: TransferRelationshipSources :exec
UPDATE relationship_sources SET relationship_id = $2 WHERE relationship_id = $1
`

type TransferRelationshipSourcesParams struct {
	RelationshipID   int64 `json:"relationship_id"`
	RelationshipID_2 int64 `json:"relationship_id_2"`
}

func (q *Queries) TransferRelationshipSources(ctx context.Context, arg TransferRelationshipSourcesParams) error {
	_, err := q.db.Exec(ctx, transferRelationshipSources, arg.RelationshipID, arg.RelationshipID_2)
	return err
}

const updateProjectRelationship = `-- name: UpdateProjectRelationship :one
UPDATE relationships SET description = $2, rank = $3, embedding = $4, updated_at = NOW() WHERE public_id = $1 RETURNING id
`

type UpdateProjectRelationshipParams struct {
	PublicID    string          `json:"public_id"`
	Description string          `json:"description"`
	Rank        float64         `json:"rank"`
	Embedding   pgvector.Vector `json:"embedding"`
}

func (q *Queries) UpdateProjectRelationship(ctx context.Context, arg UpdateProjectRelationshipParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateProjectRelationship,
		arg.PublicID,
		arg.Description,
		arg.Rank,
		arg.Embedding,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateProjectRelationshipsByIDs = `-- name: UpdateProjectRelationshipsByIDs :exec
WITH input AS (
    SELECT
        u.id,
        ($1::text[])[u.ord]::text AS description,
        ($2::vector[])[u.ord]::vector AS embedding
    FROM unnest($3::bigint[]) WITH ORDINALITY AS u(id, ord)
)
UPDATE relationships r
SET description = input.description,
    embedding = input.embedding,
    updated_at = NOW()
FROM input
WHERE r.id = input.id
`

type UpdateProjectRelationshipsByIDsParams struct {
	Descriptions []string          `json:"descriptions"`
	Embeddings   []pgvector.Vector `json:"embeddings"`
	Ids          []int64           `json:"ids"`
}

func (q *Queries) UpdateProjectRelationshipsByIDs(ctx context.Context, arg UpdateProjectRelationshipsByIDsParams) error {
	_, err := q.db.Exec(ctx, updateProjectRelationshipsByIDs, arg.Descriptions, arg.Embeddings, arg.Ids)
	return err
}

const updateRelationshipRank = `-- name: UpdateRelationshipRank :exec
UPDATE relationships SET rank = $1, updated_at = NOW() WHERE id = $2
`

type UpdateRelationshipRankParams struct {
	Rank float64 `json:"rank"`
	ID   int64   `json:"id"`
}

func (q *Queries) UpdateRelationshipRank(ctx context.Context, arg UpdateRelationshipRankParams) error {
	_, err := q.db.Exec(ctx, updateRelationshipRank, arg.Rank, arg.ID)
	return err
}

const updateRelationshipSourceEntity = `-- name: UpdateRelationshipSourceEntity :exec
UPDATE relationships SET source_id = $2 WHERE source_id = $1 AND project_id = $3
`

type UpdateRelationshipSourceEntityParams struct {
	SourceID   int64 `json:"source_id"`
	SourceID_2 int64 `json:"source_id_2"`
	ProjectID  int64 `json:"project_id"`
}

func (q *Queries) UpdateRelationshipSourceEntity(ctx context.Context, arg UpdateRelationshipSourceEntityParams) error {
	_, err := q.db.Exec(ctx, updateRelationshipSourceEntity, arg.SourceID, arg.SourceID_2, arg.ProjectID)
	return err
}

const updateRelationshipTargetEntity = `-- name: UpdateRelationshipTargetEntity :exec
UPDATE relationships SET target_id = $2 WHERE target_id = $1 AND project_id = $3
`

type UpdateRelationshipTargetEntityParams struct {
	TargetID   int64 `json:"target_id"`
	TargetID_2 int64 `json:"target_id_2"`
	ProjectID  int64 `json:"project_id"`
}

func (q *Queries) UpdateRelationshipTargetEntity(ctx context.Context, arg UpdateRelationshipTargetEntityParams) error {
	_, err := q.db.Exec(ctx, updateRelationshipTargetEntity, arg.TargetID, arg.TargetID_2, arg.ProjectID)
	return err
}

const upsertProjectRelationships = `-- name: UpsertProjectRelationships :many
WITH input AS (
    SELECT
        u.public_id,
        ($2::bigint[])[u.ord]::bigint AS source_id,
        ($3::bigint[])[u.ord]::bigint AS target_id,
        ($4::float8[])[u.ord]::float8 AS rank,
        ($5::text[])[u.ord]::text AS description,
        ($6::vector[])[u.ord]::vector AS embedding
    FROM unnest($7::text[]) WITH ORDINALITY AS u(public_id, ord)
)
INSERT INTO relationships (public_id, project_id, source_id, target_id, rank, description, embedding)
SELECT public_id, $1::bigint, source_id, target_id, rank, description, embedding
FROM input
ON CONFLICT (public_id) DO UPDATE
SET project_id = EXCLUDED.project_id,
    source_id = EXCLUDED.source_id,
    target_id = EXCLUDED.target_id,
    rank = EXCLUDED.rank,
    description = EXCLUDED.description,
    embedding = EXCLUDED.embedding,
    updated_at = NOW()
RETURNING id, public_id
`

type UpsertProjectRelationshipsParams struct {
	ProjectID    int64             `json:"project_id"`
	SourceIds    []int64           `json:"source_ids"`
	TargetIds    []int64           `json:"target_ids"`
	Ranks        []float64         `json:"ranks"`
	Descriptions []string          `json:"descriptions"`
	Embeddings   []pgvector.Vector `json:"embeddings"`
	PublicIds    []string          `json:"public_ids"`
}

type UpsertProjectRelationshipsRow struct {
	ID       int64  `json:"id"`
	PublicID string `json:"public_id"`
}

func (q *Queries) UpsertProjectRelationships(ctx context.Context, arg UpsertProjectRelationshipsParams) ([]UpsertProjectRelationshipsRow, error) {
	rows, err := q.db.Query(ctx, upsertProjectRelationships,
		arg.ProjectID,
		arg.SourceIds,
		arg.TargetIds,
		arg.Ranks,
		arg.Descriptions,
		arg.Embeddings,
		arg.PublicIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UpsertProjectRelationshipsRow{}
	for rows.Next() {
		var i UpsertProjectRelationshipsRow
		if err := rows.Scan(&i.ID, &i.PublicID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRelationshipSources = `-- name: UpsertRelationshipSources :exec
WITH input AS (
    SELECT
        u.public_id,
        ($1::bigint[])[u.ord]::bigint AS relationship_id,
        ($2::bigint[])[u.ord]::bigint AS text_unit_id,
        ($3::text[])[u.ord]::text AS description,
        ($4::vector[])[u.ord]::vector AS embedding
    FROM unnest($5::text[]) WITH ORDINALITY AS u(public_id, ord)
)
INSERT INTO relationship_sources (public_id, relationship_id, text_unit_id, description, embedding)
SELECT public_id, relationship_id, text_unit_id, description, embedding
FROM input
ON CONFLICT (public_id) DO UPDATE
SET relationship_id = EXCLUDED.relationship_id,
    text_unit_id = EXCLUDED.text_unit_id,
    description = EXCLUDED.description,
    embedding = EXCLUDED.embedding,
    updated_at = NOW()
`

type UpsertRelationshipSourcesParams struct {
	RelationshipIds []int64           `json:"relationship_ids"`
	TextUnitIds     []int64           `json:"text_unit_ids"`
	Descriptions    []string          `json:"descriptions"`
	Embeddings      []pgvector.Vector `json:"embeddings"`
	PublicIds       []string          `json:"public_ids"`
}

func (q *Queries) UpsertRelationshipSources(ctx context.Context, arg UpsertRelationshipSourcesParams) error {
	_, err := q.db.Exec(ctx, upsertRelationshipSources,
		arg.RelationshipIds,
		arg.TextUnitIds,
		arg.Descriptions,
		arg.Embeddings,
		arg.PublicIds,
	)
	return err
}
