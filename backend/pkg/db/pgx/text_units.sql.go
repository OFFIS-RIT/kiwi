// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: text_units.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteTextUnitsByFileIDs = `-- name: DeleteTextUnitsByFileIDs :exec
DELETE FROM text_units WHERE project_file_id = ANY($1::bigint[])
`

func (q *Queries) DeleteTextUnitsByFileIDs(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, deleteTextUnitsByFileIDs, dollar_1)
	return err
}

const getFilesFromTextUnitIDs = `-- name: GetFilesFromTextUnitIDs :many
WITH input_ids AS (
    SELECT DISTINCT trim(u.pid) AS pid
    FROM unnest($1::text[]) AS u(pid)
    WHERE trim(u.pid) <> ''
),
numeric_ids AS (
    SELECT pid, pid::bigint AS id
    FROM input_ids
    WHERE pid ~ '^[0-9]+$'
),
resolved_text_units AS (
    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM input_ids i
    JOIN text_units tu ON tu.public_id = i.pid

    UNION

    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM input_ids i
    JOIN entity_sources es ON es.public_id = i.pid
    JOIN text_units tu ON tu.id = es.text_unit_id

    UNION

    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM input_ids i
    JOIN relationship_sources rs ON rs.public_id = i.pid
    JOIN text_units tu ON tu.id = rs.text_unit_id

    UNION

    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM numeric_ids n
    JOIN text_units tu ON tu.id = n.id

    UNION

    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM numeric_ids n
    JOIN entity_sources es ON es.id = n.id
    JOIN text_units tu ON tu.id = es.text_unit_id

    UNION

    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM numeric_ids n
    JOIN relationship_sources rs ON rs.id = n.id
    JOIN text_units tu ON tu.id = rs.text_unit_id
)
SELECT DISTINCT f.name, f.file_key, rtu.public_id
FROM resolved_text_units rtu
JOIN project_files f ON f.id = rtu.project_file_id
`

type GetFilesFromTextUnitIDsRow struct {
	Name     string `json:"name"`
	FileKey  string `json:"file_key"`
	PublicID string `json:"public_id"`
}

func (q *Queries) GetFilesFromTextUnitIDs(ctx context.Context, dollar_1 []string) ([]GetFilesFromTextUnitIDsRow, error) {
	rows, err := q.db.Query(ctx, getFilesFromTextUnitIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesFromTextUnitIDsRow{}
	for rows.Next() {
		var i GetFilesFromTextUnitIDsRow
		if err := rows.Scan(&i.Name, &i.FileKey, &i.PublicID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesWithMetadataFromTextUnitIDs = `-- name: GetFilesWithMetadataFromTextUnitIDs :many
WITH input_ids AS (
    SELECT DISTINCT trim(u.pid) AS pid
    FROM unnest($1::text[]) AS u(pid)
    WHERE trim(u.pid) <> ''
),
numeric_ids AS (
    SELECT pid, pid::bigint AS id
    FROM input_ids
    WHERE pid ~ '^[0-9]+$'
),
resolved_text_units AS (
    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM input_ids i
    JOIN text_units tu ON tu.public_id = i.pid

    UNION

    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM input_ids i
    JOIN entity_sources es ON es.public_id = i.pid
    JOIN text_units tu ON tu.id = es.text_unit_id

    UNION

    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM input_ids i
    JOIN relationship_sources rs ON rs.public_id = i.pid
    JOIN text_units tu ON tu.id = rs.text_unit_id

    UNION

    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM numeric_ids n
    JOIN text_units tu ON tu.id = n.id

    UNION

    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM numeric_ids n
    JOIN entity_sources es ON es.id = n.id
    JOIN text_units tu ON tu.id = es.text_unit_id

    UNION

    SELECT tu.id, tu.public_id, tu.project_file_id
    FROM numeric_ids n
    JOIN relationship_sources rs ON rs.id = n.id
    JOIN text_units tu ON tu.id = rs.text_unit_id
)
SELECT DISTINCT f.name, f.file_key, f.metadata, rtu.public_id
FROM resolved_text_units rtu
JOIN project_files f ON f.id = rtu.project_file_id
`

type GetFilesWithMetadataFromTextUnitIDsRow struct {
	Name     string      `json:"name"`
	FileKey  string      `json:"file_key"`
	Metadata pgtype.Text `json:"metadata"`
	PublicID string      `json:"public_id"`
}

func (q *Queries) GetFilesWithMetadataFromTextUnitIDs(ctx context.Context, dollar_1 []string) ([]GetFilesWithMetadataFromTextUnitIDsRow, error) {
	rows, err := q.db.Query(ctx, getFilesWithMetadataFromTextUnitIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesWithMetadataFromTextUnitIDsRow{}
	for rows.Next() {
		var i GetFilesWithMetadataFromTextUnitIDsRow
		if err := rows.Scan(
			&i.Name,
			&i.FileKey,
			&i.Metadata,
			&i.PublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectIDFromTextUnit = `-- name: GetProjectIDFromTextUnit :one
SELECT p.id FROM projects p
JOIN project_files f ON f.project_id = p.id
JOIN text_units tu ON tu.project_file_id = f.id
WHERE tu.public_id = $1
`

func (q *Queries) GetProjectIDFromTextUnit(ctx context.Context, publicID string) (int64, error) {
	row := q.db.QueryRow(ctx, getProjectIDFromTextUnit, publicID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTextUnitByPublicId = `-- name: GetTextUnitByPublicId :one
SELECT id, public_id, project_file_id, text, created_at, updated_at FROM text_units
WHERE public_id = $1
`

func (q *Queries) GetTextUnitByPublicId(ctx context.Context, publicID string) (TextUnit, error) {
	row := q.db.QueryRow(ctx, getTextUnitByPublicId, publicID)
	var i TextUnit
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectFileID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTextUnitIDsByPublicIDs = `-- name: GetTextUnitIDsByPublicIDs :many
SELECT id, public_id
FROM text_units
WHERE public_id = ANY($1::text[])
`

type GetTextUnitIDsByPublicIDsRow struct {
	ID       int64  `json:"id"`
	PublicID string `json:"public_id"`
}

func (q *Queries) GetTextUnitIDsByPublicIDs(ctx context.Context, publicIds []string) ([]GetTextUnitIDsByPublicIDsRow, error) {
	rows, err := q.db.Query(ctx, getTextUnitIDsByPublicIDs, publicIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTextUnitIDsByPublicIDsRow{}
	for rows.Next() {
		var i GetTextUnitIDsByPublicIDsRow
		if err := rows.Scan(&i.ID, &i.PublicID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTextUnitIdsForFiles = `-- name: GetTextUnitIdsForFiles :many
SELECT id, public_id FROM text_units WHERE project_file_id = ANY($1::bigint[])
`

type GetTextUnitIdsForFilesRow struct {
	ID       int64  `json:"id"`
	PublicID string `json:"public_id"`
}

func (q *Queries) GetTextUnitIdsForFiles(ctx context.Context, dollar_1 []int64) ([]GetTextUnitIdsForFilesRow, error) {
	rows, err := q.db.Query(ctx, getTextUnitIdsForFiles, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTextUnitIdsForFilesRow{}
	for rows.Next() {
		var i GetTextUnitIdsForFilesRow
		if err := rows.Scan(&i.ID, &i.PublicID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertTextUnits = `-- name: UpsertTextUnits :many
WITH input AS (
    SELECT
        u.public_id,
        ($1::bigint[])[u.ord]::bigint AS project_file_id,
        ($2::text[])[u.ord]::text AS text
    FROM unnest($3::text[]) WITH ORDINALITY AS u(public_id, ord)
)
INSERT INTO text_units (public_id, project_file_id, text)
SELECT public_id, project_file_id, text
FROM input
ON CONFLICT (public_id) DO UPDATE
SET project_file_id = EXCLUDED.project_file_id,
    text = EXCLUDED.text,
    updated_at = NOW()
RETURNING id
`

type UpsertTextUnitsParams struct {
	ProjectFileIds []int64  `json:"project_file_ids"`
	Texts          []string `json:"texts"`
	PublicIds      []string `json:"public_ids"`
}

func (q *Queries) UpsertTextUnits(ctx context.Context, arg UpsertTextUnitsParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, upsertTextUnits, arg.ProjectFileIds, arg.Texts, arg.PublicIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
