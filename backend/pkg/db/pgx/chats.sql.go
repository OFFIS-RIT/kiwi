// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chats.sql

package pgdb

import (
	"context"
)

const addChatMessage = `-- name: AddChatMessage :exec
INSERT INTO chat_messages (chat_id, role, content, tool_call_id, tool_name, tool_arguments)
VALUES (
    $1::bigint,
    $2,
    $3,
    $4,
    $5,
    $6
)
`

type AddChatMessageParams struct {
	ChatID        int64  `json:"chat_id"`
	Role          string `json:"role"`
	Content       string `json:"content"`
	ToolCallID    string `json:"tool_call_id"`
	ToolName      string `json:"tool_name"`
	ToolArguments string `json:"tool_arguments"`
}

func (q *Queries) AddChatMessage(ctx context.Context, arg AddChatMessageParams) error {
	_, err := q.db.Exec(ctx, addChatMessage,
		arg.ChatID,
		arg.Role,
		arg.Content,
		arg.ToolCallID,
		arg.ToolName,
		arg.ToolArguments,
	)
	return err
}

const createUserChat = `-- name: CreateUserChat :one
INSERT INTO user_chats (public_id, user_id, project_id, title)
VALUES (
    $1,
    $2,
    $3::bigint,
    $4
)
RETURNING id, public_id, user_id, project_id, title, created_at, updated_at
`

type CreateUserChatParams struct {
	PublicID  string `json:"public_id"`
	UserID    int64  `json:"user_id"`
	ProjectID int64  `json:"project_id"`
	Title     string `json:"title"`
}

func (q *Queries) CreateUserChat(ctx context.Context, arg CreateUserChatParams) (UserChat, error) {
	row := q.db.QueryRow(ctx, createUserChat,
		arg.PublicID,
		arg.UserID,
		arg.ProjectID,
		arg.Title,
	)
	var i UserChat
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatMessagesByChatID = `-- name: GetChatMessagesByChatID :many
SELECT id, chat_id, role, content, tool_call_id, tool_name, tool_arguments, created_at, updated_at FROM chat_messages
WHERE chat_id = $1::bigint
ORDER BY id ASC
`

func (q *Queries) GetChatMessagesByChatID(ctx context.Context, chatID int64) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, getChatMessagesByChatID, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatMessage{}
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.Role,
			&i.Content,
			&i.ToolCallID,
			&i.ToolName,
			&i.ToolArguments,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserChatByPublicIDAndProject = `-- name: GetUserChatByPublicIDAndProject :one
SELECT id, public_id, user_id, project_id, title, created_at, updated_at FROM user_chats
WHERE public_id = $1
  AND user_id = $2
  AND project_id = $3::bigint
`

type GetUserChatByPublicIDAndProjectParams struct {
	PublicID  string `json:"public_id"`
	UserID    int64  `json:"user_id"`
	ProjectID int64  `json:"project_id"`
}

func (q *Queries) GetUserChatByPublicIDAndProject(ctx context.Context, arg GetUserChatByPublicIDAndProjectParams) (UserChat, error) {
	row := q.db.QueryRow(ctx, getUserChatByPublicIDAndProject, arg.PublicID, arg.UserID, arg.ProjectID)
	var i UserChat
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.UserID,
		&i.ProjectID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const touchUserChat = `-- name: TouchUserChat :exec
UPDATE user_chats
SET updated_at = NOW()
WHERE id = $1::bigint
`

func (q *Queries) TouchUserChat(ctx context.Context, chatID int64) error {
	_, err := q.db.Exec(ctx, touchUserChat, chatID)
	return err
}
