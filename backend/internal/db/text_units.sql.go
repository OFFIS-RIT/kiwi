// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: text_units.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProjectFileTextUnit = `-- name: AddProjectFileTextUnit :one
INSERT INTO text_units (public_id, project_file_id, text)
VALUES ($1, $2, $3)
ON CONFLICT (public_id) DO UPDATE
SET project_file_id = EXCLUDED.project_file_id,
    text = EXCLUDED.text,
    updated_at = NOW()
RETURNING id
`

type AddProjectFileTextUnitParams struct {
	PublicID      string `json:"public_id"`
	ProjectFileID int64  `json:"project_file_id"`
	Text          string `json:"text"`
}

func (q *Queries) AddProjectFileTextUnit(ctx context.Context, arg AddProjectFileTextUnitParams) (int64, error) {
	row := q.db.QueryRow(ctx, addProjectFileTextUnit, arg.PublicID, arg.ProjectFileID, arg.Text)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteTextUnitsByFileIDs = `-- name: DeleteTextUnitsByFileIDs :exec
DELETE FROM text_units WHERE project_file_id = ANY($1::bigint[])
`

func (q *Queries) DeleteTextUnitsByFileIDs(ctx context.Context, dollar_1 []int64) error {
	_, err := q.db.Exec(ctx, deleteTextUnitsByFileIDs, dollar_1)
	return err
}

const getFilesFromTextUnitIDs = `-- name: GetFilesFromTextUnitIDs :many
SELECT f.name, f.file_key, tu.public_id FROM project_files f
JOIN text_units tu
    ON tu.project_file_id = f.id
JOIN unnest($1::text[]) AS u(pid)
    ON tu.public_id = u.pid
`

type GetFilesFromTextUnitIDsRow struct {
	Name     string `json:"name"`
	FileKey  string `json:"file_key"`
	PublicID string `json:"public_id"`
}

func (q *Queries) GetFilesFromTextUnitIDs(ctx context.Context, dollar_1 []string) ([]GetFilesFromTextUnitIDsRow, error) {
	rows, err := q.db.Query(ctx, getFilesFromTextUnitIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesFromTextUnitIDsRow{}
	for rows.Next() {
		var i GetFilesFromTextUnitIDsRow
		if err := rows.Scan(&i.Name, &i.FileKey, &i.PublicID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesWithMetadataFromTextUnitIDs = `-- name: GetFilesWithMetadataFromTextUnitIDs :many
SELECT f.name, f.file_key, f.metadata, tu.public_id 
FROM project_files f
JOIN text_units tu ON tu.project_file_id = f.id
JOIN unnest($1::text[]) AS u(pid) ON tu.public_id = u.pid
`

type GetFilesWithMetadataFromTextUnitIDsRow struct {
	Name     string      `json:"name"`
	FileKey  string      `json:"file_key"`
	Metadata pgtype.Text `json:"metadata"`
	PublicID string      `json:"public_id"`
}

func (q *Queries) GetFilesWithMetadataFromTextUnitIDs(ctx context.Context, dollar_1 []string) ([]GetFilesWithMetadataFromTextUnitIDsRow, error) {
	rows, err := q.db.Query(ctx, getFilesWithMetadataFromTextUnitIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesWithMetadataFromTextUnitIDsRow{}
	for rows.Next() {
		var i GetFilesWithMetadataFromTextUnitIDsRow
		if err := rows.Scan(
			&i.Name,
			&i.FileKey,
			&i.Metadata,
			&i.PublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectIDFromTextUnit = `-- name: GetProjectIDFromTextUnit :one
SELECT p.id FROM projects p
JOIN project_files f ON f.project_id = p.id
JOIN text_units tu ON tu.project_file_id = f.id
WHERE tu.public_id = $1
`

func (q *Queries) GetProjectIDFromTextUnit(ctx context.Context, publicID string) (int64, error) {
	row := q.db.QueryRow(ctx, getProjectIDFromTextUnit, publicID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTextUnitByPublicId = `-- name: GetTextUnitByPublicId :one
SELECT id, public_id, project_file_id, text, created_at, updated_at FROM text_units
WHERE public_id = $1
`

func (q *Queries) GetTextUnitByPublicId(ctx context.Context, publicID string) (TextUnit, error) {
	row := q.db.QueryRow(ctx, getTextUnitByPublicId, publicID)
	var i TextUnit
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.ProjectFileID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTextUnitIdsForFiles = `-- name: GetTextUnitIdsForFiles :many
SELECT id, public_id FROM text_units WHERE project_file_id = ANY($1::bigint[])
`

type GetTextUnitIdsForFilesRow struct {
	ID       int64  `json:"id"`
	PublicID string `json:"public_id"`
}

func (q *Queries) GetTextUnitIdsForFiles(ctx context.Context, dollar_1 []int64) ([]GetTextUnitIdsForFilesRow, error) {
	rows, err := q.db.Query(ctx, getTextUnitIdsForFiles, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTextUnitIdsForFilesRow{}
	for rows.Next() {
		var i GetTextUnitIdsForFilesRow
		if err := rows.Scan(&i.ID, &i.PublicID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
