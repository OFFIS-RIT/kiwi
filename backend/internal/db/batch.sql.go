// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: batch.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const areAllBatchesCompleted = `-- name: AreAllBatchesCompleted :one
SELECT (COUNT(*) FILTER (WHERE status != 'completed') = 0)::bool as all_completed
FROM project_batch_status
WHERE correlation_id = $1
`

func (q *Queries) AreAllBatchesCompleted(ctx context.Context, correlationID string) (bool, error) {
	row := q.db.QueryRow(ctx, areAllBatchesCompleted, correlationID)
	var all_completed bool
	err := row.Scan(&all_completed)
	return all_completed, err
}

const countCompletedBatches = `-- name: CountCompletedBatches :one
SELECT COUNT(*)::int FROM project_batch_status
WHERE correlation_id = $1 AND status = 'completed'
`

func (q *Queries) CountCompletedBatches(ctx context.Context, correlationID string) (int32, error) {
	row := q.db.QueryRow(ctx, countCompletedBatches, correlationID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createBatchStatus = `-- name: CreateBatchStatus :one
INSERT INTO project_batch_status (
    project_id, correlation_id, batch_id, total_batches, files_count, file_ids, operation
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, project_id, correlation_id, batch_id, total_batches, files_count, file_ids, status, operation, estimated_duration, created_at, started_at, completed_at, error_message
`

type CreateBatchStatusParams struct {
	ProjectID     int64   `json:"project_id"`
	CorrelationID string  `json:"correlation_id"`
	BatchID       int32   `json:"batch_id"`
	TotalBatches  int32   `json:"total_batches"`
	FilesCount    int32   `json:"files_count"`
	FileIds       []int64 `json:"file_ids"`
	Operation     string  `json:"operation"`
}

func (q *Queries) CreateBatchStatus(ctx context.Context, arg CreateBatchStatusParams) (ProjectBatchStatus, error) {
	row := q.db.QueryRow(ctx, createBatchStatus,
		arg.ProjectID,
		arg.CorrelationID,
		arg.BatchID,
		arg.TotalBatches,
		arg.FilesCount,
		arg.FileIds,
		arg.Operation,
	)
	var i ProjectBatchStatus
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CorrelationID,
		&i.BatchID,
		&i.TotalBatches,
		&i.FilesCount,
		&i.FileIds,
		&i.Status,
		&i.Operation,
		&i.EstimatedDuration,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
	)
	return i, err
}

const deleteBatchStatusByCorrelation = `-- name: DeleteBatchStatusByCorrelation :exec
DELETE FROM project_batch_status WHERE correlation_id = $1
`

func (q *Queries) DeleteBatchStatusByCorrelation(ctx context.Context, correlationID string) error {
	_, err := q.db.Exec(ctx, deleteBatchStatusByCorrelation, correlationID)
	return err
}

const deleteOldCompletedBatches = `-- name: DeleteOldCompletedBatches :exec
DELETE FROM project_batch_status 
WHERE status = 'completed' AND completed_at < NOW() - INTERVAL '7 days'
`

func (q *Queries) DeleteOldCompletedBatches(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldCompletedBatches)
	return err
}

const getBatchStatus = `-- name: GetBatchStatus :one
SELECT id, project_id, correlation_id, batch_id, total_batches, files_count, file_ids, status, operation, estimated_duration, created_at, started_at, completed_at, error_message FROM project_batch_status
WHERE correlation_id = $1 AND batch_id = $2
`

type GetBatchStatusParams struct {
	CorrelationID string `json:"correlation_id"`
	BatchID       int32  `json:"batch_id"`
}

func (q *Queries) GetBatchStatus(ctx context.Context, arg GetBatchStatusParams) (ProjectBatchStatus, error) {
	row := q.db.QueryRow(ctx, getBatchStatus, arg.CorrelationID, arg.BatchID)
	var i ProjectBatchStatus
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CorrelationID,
		&i.BatchID,
		&i.TotalBatches,
		&i.FilesCount,
		&i.FileIds,
		&i.Status,
		&i.Operation,
		&i.EstimatedDuration,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
	)
	return i, err
}

const getBatchesByCorrelation = `-- name: GetBatchesByCorrelation :many
SELECT id, project_id, correlation_id, batch_id, total_batches, files_count, file_ids, status, operation, estimated_duration, created_at, started_at, completed_at, error_message FROM project_batch_status
WHERE correlation_id = $1
ORDER BY batch_id
`

func (q *Queries) GetBatchesByCorrelation(ctx context.Context, correlationID string) ([]ProjectBatchStatus, error) {
	rows, err := q.db.Query(ctx, getBatchesByCorrelation, correlationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectBatchStatus{}
	for rows.Next() {
		var i ProjectBatchStatus
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.CorrelationID,
			&i.BatchID,
			&i.TotalBatches,
			&i.FilesCount,
			&i.FileIds,
			&i.Status,
			&i.Operation,
			&i.EstimatedDuration,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestCorrelationForProject = `-- name: GetLatestCorrelationForProject :one
SELECT correlation_id FROM project_batch_status
WHERE project_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestCorrelationForProject(ctx context.Context, projectID int64) (string, error) {
	row := q.db.QueryRow(ctx, getLatestCorrelationForProject, projectID)
	var correlation_id string
	err := row.Scan(&correlation_id)
	return correlation_id, err
}

const getPendingBatchesForProject = `-- name: GetPendingBatchesForProject :many
SELECT id, project_id, correlation_id, batch_id, total_batches, files_count, file_ids, status, operation, estimated_duration, created_at, started_at, completed_at, error_message FROM project_batch_status
WHERE project_id = $1 AND status IN ('pending', 'preprocessing', 'extracting', 'indexing')
ORDER BY created_at
`

func (q *Queries) GetPendingBatchesForProject(ctx context.Context, projectID int64) ([]ProjectBatchStatus, error) {
	rows, err := q.db.Query(ctx, getPendingBatchesForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectBatchStatus{}
	for rows.Next() {
		var i ProjectBatchStatus
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.CorrelationID,
			&i.BatchID,
			&i.TotalBatches,
			&i.FilesCount,
			&i.FileIds,
			&i.Status,
			&i.Operation,
			&i.EstimatedDuration,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectBatchProgress = `-- name: GetProjectBatchProgress :one
SELECT 
    COUNT(*) FILTER (WHERE status = 'pending')::int AS pending_count,
    COUNT(*) FILTER (WHERE status = 'preprocessing')::int AS preprocessing_count,
    COUNT(*) FILTER (WHERE status = 'preprocessed')::int AS preprocessed_count,
    COUNT(*) FILTER (WHERE status = 'extracting')::int AS extracting_count,
    COUNT(*) FILTER (WHERE status = 'indexing')::int AS indexing_count,
    COUNT(*) FILTER (WHERE status = 'completed')::int AS completed_count,
    COUNT(*) FILTER (WHERE status = 'failed')::int AS failed_count,
    COUNT(*)::int AS total_count,
    COALESCE(SUM(estimated_duration), 0)::bigint AS total_estimated_duration,
    COALESCE(SUM(estimated_duration) FILTER (WHERE status NOT IN ('completed', 'failed')), 0)::bigint AS remaining_estimated_duration
FROM project_batch_status
WHERE correlation_id = $1
`

type GetProjectBatchProgressRow struct {
	PendingCount               int32 `json:"pending_count"`
	PreprocessingCount         int32 `json:"preprocessing_count"`
	PreprocessedCount          int32 `json:"preprocessed_count"`
	ExtractingCount            int32 `json:"extracting_count"`
	IndexingCount              int32 `json:"indexing_count"`
	CompletedCount             int32 `json:"completed_count"`
	FailedCount                int32 `json:"failed_count"`
	TotalCount                 int32 `json:"total_count"`
	TotalEstimatedDuration     int64 `json:"total_estimated_duration"`
	RemainingEstimatedDuration int64 `json:"remaining_estimated_duration"`
}

func (q *Queries) GetProjectBatchProgress(ctx context.Context, correlationID string) (GetProjectBatchProgressRow, error) {
	row := q.db.QueryRow(ctx, getProjectBatchProgress, correlationID)
	var i GetProjectBatchProgressRow
	err := row.Scan(
		&i.PendingCount,
		&i.PreprocessingCount,
		&i.PreprocessedCount,
		&i.ExtractingCount,
		&i.IndexingCount,
		&i.CompletedCount,
		&i.FailedCount,
		&i.TotalCount,
		&i.TotalEstimatedDuration,
		&i.RemainingEstimatedDuration,
	)
	return i, err
}

const getProjectFilesForBatch = `-- name: GetProjectFilesForBatch :many
SELECT id, project_id, name, file_key, deleted, token_count, metadata, created_at, updated_at FROM project_files
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetProjectFilesForBatch(ctx context.Context, dollar_1 []int64) ([]ProjectFile, error) {
	rows, err := q.db.Query(ctx, getProjectFilesForBatch, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectFile{}
	for rows.Next() {
		var i ProjectFile
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.FileKey,
			&i.Deleted,
			&i.TokenCount,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleBatches = `-- name: GetStaleBatches :many
SELECT id, project_id, correlation_id, batch_id, total_batches, files_count, file_ids, status, operation, estimated_duration, created_at, started_at, completed_at, error_message FROM project_batch_status
WHERE status IN ('preprocessing', 'extracting', 'indexing')
  AND started_at < NOW() - INTERVAL '10 hours'
`

func (q *Queries) GetStaleBatches(ctx context.Context) ([]ProjectBatchStatus, error) {
	rows, err := q.db.Query(ctx, getStaleBatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectBatchStatus{}
	for rows.Next() {
		var i ProjectBatchStatus
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.CorrelationID,
			&i.BatchID,
			&i.TotalBatches,
			&i.FilesCount,
			&i.FileIds,
			&i.Status,
			&i.Operation,
			&i.EstimatedDuration,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetBatchToPending = `-- name: ResetBatchToPending :exec
UPDATE project_batch_status
SET status = 'pending',
    started_at = NULL
WHERE correlation_id = $1 AND batch_id = $2 AND status = 'preprocessing'
`

type ResetBatchToPendingParams struct {
	CorrelationID string `json:"correlation_id"`
	BatchID       int32  `json:"batch_id"`
}

func (q *Queries) ResetBatchToPending(ctx context.Context, arg ResetBatchToPendingParams) error {
	_, err := q.db.Exec(ctx, resetBatchToPending, arg.CorrelationID, arg.BatchID)
	return err
}

const resetBatchToPreprocessed = `-- name: ResetBatchToPreprocessed :exec
UPDATE project_batch_status
SET status = 'preprocessed',
    started_at = NULL
WHERE correlation_id = $1 AND batch_id = $2 AND status = 'indexing'
`

type ResetBatchToPreprocessedParams struct {
	CorrelationID string `json:"correlation_id"`
	BatchID       int32  `json:"batch_id"`
}

func (q *Queries) ResetBatchToPreprocessed(ctx context.Context, arg ResetBatchToPreprocessedParams) error {
	_, err := q.db.Exec(ctx, resetBatchToPreprocessed, arg.CorrelationID, arg.BatchID)
	return err
}

const resetStaleBatchExtractingToPreprocessed = `-- name: ResetStaleBatchExtractingToPreprocessed :exec
UPDATE project_batch_status
SET status = 'preprocessed',
    started_at = NULL,
    error_message = 'Reset: stale extracting state'
WHERE id = $1 AND status = 'extracting'
`

func (q *Queries) ResetStaleBatchExtractingToPreprocessed(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, resetStaleBatchExtractingToPreprocessed, id)
	return err
}

const resetStaleBatchToPending = `-- name: ResetStaleBatchToPending :exec
UPDATE project_batch_status
SET status = 'pending',
    started_at = NULL,
    error_message = 'Reset: stale preprocessing state'
WHERE id = $1 AND status = 'preprocessing'
`

func (q *Queries) ResetStaleBatchToPending(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, resetStaleBatchToPending, id)
	return err
}

const resetStaleBatchToPreprocessed = `-- name: ResetStaleBatchToPreprocessed :exec
UPDATE project_batch_status
SET status = 'preprocessed',
    started_at = NULL,
    error_message = 'Reset: stale indexing state'
WHERE id = $1 AND status = 'indexing'
`

func (q *Queries) ResetStaleBatchToPreprocessed(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, resetStaleBatchToPreprocessed, id)
	return err
}

const updateBatchEstimatedDuration = `-- name: UpdateBatchEstimatedDuration :exec
UPDATE project_batch_status
SET estimated_duration = $3
WHERE correlation_id = $1 AND batch_id = $2
`

type UpdateBatchEstimatedDurationParams struct {
	CorrelationID     string `json:"correlation_id"`
	BatchID           int32  `json:"batch_id"`
	EstimatedDuration int64  `json:"estimated_duration"`
}

func (q *Queries) UpdateBatchEstimatedDuration(ctx context.Context, arg UpdateBatchEstimatedDurationParams) error {
	_, err := q.db.Exec(ctx, updateBatchEstimatedDuration, arg.CorrelationID, arg.BatchID, arg.EstimatedDuration)
	return err
}

const updateBatchStatus = `-- name: UpdateBatchStatus :exec
UPDATE project_batch_status
SET status = $3::text,
    started_at = CASE WHEN $3::text IN ('preprocessing', 'extracting', 'indexing') THEN NOW() ELSE started_at END,
    completed_at = CASE WHEN $3::text IN ('completed', 'failed') THEN NOW() ELSE completed_at END,
    error_message = $4
WHERE correlation_id = $1 AND batch_id = $2
`

type UpdateBatchStatusParams struct {
	CorrelationID string      `json:"correlation_id"`
	BatchID       int32       `json:"batch_id"`
	Column3       string      `json:"column_3"`
	ErrorMessage  pgtype.Text `json:"error_message"`
}

func (q *Queries) UpdateBatchStatus(ctx context.Context, arg UpdateBatchStatusParams) error {
	_, err := q.db.Exec(ctx, updateBatchStatus,
		arg.CorrelationID,
		arg.BatchID,
		arg.Column3,
		arg.ErrorMessage,
	)
	return err
}
