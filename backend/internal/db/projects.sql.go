// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acquireProjectLock = `-- name: AcquireProjectLock :exec
SELECT pg_advisory_lock($1::bigint)
`

func (q *Queries) AcquireProjectLock(ctx context.Context, dollar_1 int64) error {
	_, err := q.db.Exec(ctx, acquireProjectLock, dollar_1)
	return err
}

const acquireProjectXactLock = `-- name: AcquireProjectXactLock :exec
SELECT pg_advisory_xact_lock($1::bigint)
`

func (q *Queries) AcquireProjectXactLock(ctx context.Context, dollar_1 int64) error {
	_, err := q.db.Exec(ctx, acquireProjectXactLock, dollar_1)
	return err
}

const addFileToProject = `-- name: AddFileToProject :one
INSERT INTO project_files (project_id, name, file_key)
VALUES ($1, $2, $3) RETURNING id, project_id, name, file_key, deleted, token_count, metadata, created_at, updated_at
`

type AddFileToProjectParams struct {
	ProjectID int64  `json:"project_id"`
	Name      string `json:"name"`
	FileKey   string `json:"file_key"`
}

func (q *Queries) AddFileToProject(ctx context.Context, arg AddFileToProjectParams) (ProjectFile, error) {
	row := q.db.QueryRow(ctx, addFileToProject, arg.ProjectID, arg.Name, arg.FileKey)
	var i ProjectFile
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.FileKey,
		&i.Deleted,
		&i.TokenCount,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const addProjectUpdate = `-- name: AddProjectUpdate :exec
INSERT INTO project_updates (project_id, update_type, update_message)
VALUES ($1, $2, $3)
`

type AddProjectUpdateParams struct {
	ProjectID     int64  `json:"project_id"`
	UpdateType    string `json:"update_type"`
	UpdateMessage []byte `json:"update_message"`
}

func (q *Queries) AddProjectUpdate(ctx context.Context, arg AddProjectUpdateParams) error {
	_, err := q.db.Exec(ctx, addProjectUpdate, arg.ProjectID, arg.UpdateType, arg.UpdateMessage)
	return err
}

const addTokenCountToFile = `-- name: AddTokenCountToFile :exec
UPDATE project_files SET token_count = $2 WHERE id = $1
`

type AddTokenCountToFileParams struct {
	ID         int64 `json:"id"`
	TokenCount int32 `json:"token_count"`
}

func (q *Queries) AddTokenCountToFile(ctx context.Context, arg AddTokenCountToFileParams) error {
	_, err := q.db.Exec(ctx, addTokenCountToFile, arg.ID, arg.TokenCount)
	return err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (group_id, name, state)
VALUES ($1, $2, $3) RETURNING id, group_id, name, state, created_at, updated_at
`

type CreateProjectParams struct {
	GroupID int64  `json:"group_id"`
	Name    string `json:"name"`
	State   string `json:"state"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject, arg.GroupID, arg.Name, arg.State)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFileFromProject = `-- name: DeleteFileFromProject :exec
DELETE FROM project_files
WHERE project_id = $1 AND file_key = $2
`

type DeleteFileFromProjectParams struct {
	ProjectID int64  `json:"project_id"`
	FileKey   string `json:"file_key"`
}

func (q *Queries) DeleteFileFromProject(ctx context.Context, arg DeleteFileFromProjectParams) error {
	_, err := q.db.Exec(ctx, deleteFileFromProject, arg.ProjectID, arg.FileKey)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const deleteProjectFile = `-- name: DeleteProjectFile :exec
DELETE FROM project_files WHERE id = $1
`

func (q *Queries) DeleteProjectFile(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProjectFile, id)
	return err
}

const getActiveProjectFiles = `-- name: GetActiveProjectFiles :many
SELECT id, project_id, name, file_key, deleted, token_count, metadata, created_at, updated_at FROM project_files 
WHERE project_id = $1 AND (deleted = false OR deleted IS NULL)
`

func (q *Queries) GetActiveProjectFiles(ctx context.Context, projectID int64) ([]ProjectFile, error) {
	rows, err := q.db.Query(ctx, getActiveProjectFiles, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectFile{}
	for rows.Next() {
		var i ProjectFile
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.FileKey,
			&i.Deleted,
			&i.TokenCount,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjectsWithGroups = `-- name: GetAllProjectsWithGroups :many
SELECT
    g.id   AS group_id,
    g.name AS group_name,
    p.id   AS project_id,
    p.name AS project_name,
    p.state AS project_state,
    'admin'::TEXT AS role
FROM groups AS g
JOIN projects AS p ON p.group_id = g.id
ORDER BY g.id, p.id
`

type GetAllProjectsWithGroupsRow struct {
	GroupID      int64  `json:"group_id"`
	GroupName    string `json:"group_name"`
	ProjectID    int64  `json:"project_id"`
	ProjectName  string `json:"project_name"`
	ProjectState string `json:"project_state"`
	Role         string `json:"role"`
}

func (q *Queries) GetAllProjectsWithGroups(ctx context.Context) ([]GetAllProjectsWithGroupsRow, error) {
	rows, err := q.db.Query(ctx, getAllProjectsWithGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllProjectsWithGroupsRow{}
	for rows.Next() {
		var i GetAllProjectsWithGroupsRow
		if err := rows.Scan(
			&i.GroupID,
			&i.GroupName,
			&i.ProjectID,
			&i.ProjectName,
			&i.ProjectState,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedProjectFiles = `-- name: GetDeletedProjectFiles :many
SELECT id, project_id, name, file_key, deleted, token_count, metadata, created_at, updated_at FROM project_files WHERE project_id = $1 AND deleted = true
`

func (q *Queries) GetDeletedProjectFiles(ctx context.Context, projectID int64) ([]ProjectFile, error) {
	rows, err := q.db.Query(ctx, getDeletedProjectFiles, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectFile{}
	for rows.Next() {
		var i ProjectFile
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.FileKey,
			&i.Deleted,
			&i.TokenCount,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectFiles = `-- name: GetProjectFiles :many
SELECT id, project_id, name, file_key, deleted, token_count, metadata, created_at, updated_at FROM project_files WHERE project_id = $1
`

func (q *Queries) GetProjectFiles(ctx context.Context, projectID int64) ([]ProjectFile, error) {
	rows, err := q.db.Query(ctx, getProjectFiles, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectFile{}
	for rows.Next() {
		var i ProjectFile
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.FileKey,
			&i.Deleted,
			&i.TokenCount,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectIDsForFiles = `-- name: GetProjectIDsForFiles :many
SELECT DISTINCT project_id
FROM project_files
WHERE id = ANY($1::bigint[])
`

func (q *Queries) GetProjectIDsForFiles(ctx context.Context, fileIds []int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getProjectIDsForFiles, fileIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var project_id int64
		if err := rows.Scan(&project_id); err != nil {
			return nil, err
		}
		items = append(items, project_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectSystemPrompts = `-- name: GetProjectSystemPrompts :many
SELECT id, project_id, prompt, created_at, updated_at FROM project_system_prompts WHERE project_id = $1
`

func (q *Queries) GetProjectSystemPrompts(ctx context.Context, projectID int64) ([]ProjectSystemPrompt, error) {
	rows, err := q.db.Query(ctx, getProjectSystemPrompts, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectSystemPrompt{}
	for rows.Next() {
		var i ProjectSystemPrompt
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Prompt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjects = `-- name: GetProjects :many
SELECT id, group_id, name, state, created_at, updated_at FROM projects
`

func (q *Queries) GetProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Name,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByGroup = `-- name: GetProjectsByGroup :many
SELECT id, group_id, name, state, created_at, updated_at FROM projects WHERE group_id = $1
`

func (q *Queries) GetProjectsByGroup(ctx context.Context, groupID int64) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Name,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsForUser = `-- name: GetProjectsForUser :many
SELECT
    g.id   AS group_id,
    g.name AS group_name,
    p.id   AS project_id,
    p.name AS project_name,
    p.state AS project_state,
    gu.role as role
FROM groups AS g
JOIN projects AS p
    ON p.group_id = g.id
JOIN group_users AS gu
    ON gu.group_id = g.id
WHERE gu.user_id = $1
ORDER BY g.id, p.id
`

type GetProjectsForUserRow struct {
	GroupID      int64  `json:"group_id"`
	GroupName    string `json:"group_name"`
	ProjectID    int64  `json:"project_id"`
	ProjectName  string `json:"project_name"`
	ProjectState string `json:"project_state"`
	Role         string `json:"role"`
}

func (q *Queries) GetProjectsForUser(ctx context.Context, userID int64) ([]GetProjectsForUserRow, error) {
	rows, err := q.db.Query(ctx, getProjectsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectsForUserRow{}
	for rows.Next() {
		var i GetProjectsForUserRow
		if err := rows.Scan(
			&i.GroupID,
			&i.GroupName,
			&i.ProjectID,
			&i.ProjectName,
			&i.ProjectState,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenCountOfFile = `-- name: GetTokenCountOfFile :one
SELECT token_count FROM project_files WHERE id = $1
`

func (q *Queries) GetTokenCountOfFile(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRow(ctx, getTokenCountOfFile, id)
	var token_count int32
	err := row.Scan(&token_count)
	return token_count, err
}

const isUserInProject = `-- name: IsUserInProject :one
SELECT
    COUNT(*) AS count
FROM projects AS p
JOIN groups AS g
    ON g.id = p.group_id
JOIN group_users AS gu
    ON gu.group_id = g.id
WHERE gu.user_id = $1 AND p.id = $2
`

type IsUserInProjectParams struct {
	UserID int64 `json:"user_id"`
	ID     int64 `json:"id"`
}

func (q *Queries) IsUserInProject(ctx context.Context, arg IsUserInProjectParams) (int64, error) {
	row := q.db.QueryRow(ctx, isUserInProject, arg.UserID, arg.ID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const markProjectFileAsDeleted = `-- name: MarkProjectFileAsDeleted :exec
UPDATE project_files 
SET deleted = true 
WHERE project_id = $1 AND file_key = $2
`

type MarkProjectFileAsDeletedParams struct {
	ProjectID int64  `json:"project_id"`
	FileKey   string `json:"file_key"`
}

func (q *Queries) MarkProjectFileAsDeleted(ctx context.Context, arg MarkProjectFileAsDeletedParams) error {
	_, err := q.db.Exec(ctx, markProjectFileAsDeleted, arg.ProjectID, arg.FileKey)
	return err
}

const releaseProjectLock = `-- name: ReleaseProjectLock :exec
SELECT pg_advisory_unlock($1::bigint)
`

func (q *Queries) ReleaseProjectLock(ctx context.Context, dollar_1 int64) error {
	_, err := q.db.Exec(ctx, releaseProjectLock, dollar_1)
	return err
}

const tryAcquireProjectLock = `-- name: TryAcquireProjectLock :one
SELECT pg_try_advisory_lock($1::bigint) as acquired
`

func (q *Queries) TryAcquireProjectLock(ctx context.Context, dollar_1 int64) (bool, error) {
	row := q.db.QueryRow(ctx, tryAcquireProjectLock, dollar_1)
	var acquired bool
	err := row.Scan(&acquired)
	return acquired, err
}

const tryAcquireProjectXactLock = `-- name: TryAcquireProjectXactLock :one
SELECT pg_try_advisory_xact_lock($1::bigint) as acquired
`

func (q *Queries) TryAcquireProjectXactLock(ctx context.Context, dollar_1 int64) (bool, error) {
	row := q.db.QueryRow(ctx, tryAcquireProjectXactLock, dollar_1)
	var acquired bool
	err := row.Scan(&acquired)
	return acquired, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects SET name = $2 WHERE id = $1 RETURNING id, group_id, name, state, created_at, updated_at
`

type UpdateProjectParams struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject, arg.ID, arg.Name)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProjectFileMetadata = `-- name: UpdateProjectFileMetadata :exec
UPDATE project_files SET metadata = $2, updated_at = NOW() WHERE id = $1
`

type UpdateProjectFileMetadataParams struct {
	ID       int64       `json:"id"`
	Metadata pgtype.Text `json:"metadata"`
}

func (q *Queries) UpdateProjectFileMetadata(ctx context.Context, arg UpdateProjectFileMetadataParams) error {
	_, err := q.db.Exec(ctx, updateProjectFileMetadata, arg.ID, arg.Metadata)
	return err
}

const updateProjectState = `-- name: UpdateProjectState :one
UPDATE projects SET state = $2 WHERE id = $1 RETURNING id, group_id, name, state, created_at, updated_at
`

type UpdateProjectStateParams struct {
	ID    int64  `json:"id"`
	State string `json:"state"`
}

func (q *Queries) UpdateProjectState(ctx context.Context, arg UpdateProjectStateParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProjectState, arg.ID, arg.State)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
