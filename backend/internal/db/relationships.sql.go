// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: relationships.sql

package db

import (
	"context"

	"github.com/pgvector/pgvector-go"
)

const addProjectRelationship = `-- name: AddProjectRelationship :one
INSERT INTO relationships (public_id, project_id, source_id, target_id, rank, description, embedding)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (public_id) DO UPDATE
SET project_id = EXCLUDED.project_id,
    source_id = EXCLUDED.source_id,
    target_id = EXCLUDED.target_id,
    rank = EXCLUDED.rank,
    description = EXCLUDED.description,
    embedding = EXCLUDED.embedding,
    updated_at = NOW()
RETURNING id
`

type AddProjectRelationshipParams struct {
	PublicID    string          `json:"public_id"`
	ProjectID   int64           `json:"project_id"`
	SourceID    int64           `json:"source_id"`
	TargetID    int64           `json:"target_id"`
	Rank        float64         `json:"rank"`
	Description string          `json:"description"`
	Embedding   pgvector.Vector `json:"embedding"`
}

func (q *Queries) AddProjectRelationship(ctx context.Context, arg AddProjectRelationshipParams) (int64, error) {
	row := q.db.QueryRow(ctx, addProjectRelationship,
		arg.PublicID,
		arg.ProjectID,
		arg.SourceID,
		arg.TargetID,
		arg.Rank,
		arg.Description,
		arg.Embedding,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addProjectRelationshipSource = `-- name: AddProjectRelationshipSource :one
INSERT INTO relationship_sources (public_id, relationship_id, text_unit_id, description, embedding)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (public_id) DO UPDATE
SET relationship_id = EXCLUDED.relationship_id,
    text_unit_id = EXCLUDED.text_unit_id,
    description = EXCLUDED.description,
    embedding = EXCLUDED.embedding,
    updated_at = NOW()
RETURNING id
`

type AddProjectRelationshipSourceParams struct {
	PublicID       string          `json:"public_id"`
	RelationshipID int64           `json:"relationship_id"`
	TextUnitID     int64           `json:"text_unit_id"`
	Description    string          `json:"description"`
	Embedding      pgvector.Vector `json:"embedding"`
}

func (q *Queries) AddProjectRelationshipSource(ctx context.Context, arg AddProjectRelationshipSourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, addProjectRelationshipSource,
		arg.PublicID,
		arg.RelationshipID,
		arg.TextUnitID,
		arg.Description,
		arg.Embedding,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const countRelationshipSourcesFromUnits = `-- name: CountRelationshipSourcesFromUnits :one
SELECT COUNT(*)::int
FROM relationship_sources rs
WHERE rs.relationship_id = $1
  AND rs.text_unit_id = ANY($2::bigint[])
`

type CountRelationshipSourcesFromUnitsParams struct {
	RelationshipID int64   `json:"relationship_id"`
	Column2        []int64 `json:"column_2"`
}

func (q *Queries) CountRelationshipSourcesFromUnits(ctx context.Context, arg CountRelationshipSourcesFromUnitsParams) (int32, error) {
	row := q.db.QueryRow(ctx, countRelationshipSourcesFromUnits, arg.RelationshipID, arg.Column2)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteProjectRelationship = `-- name: DeleteProjectRelationship :exec
DELETE FROM relationships WHERE id = $1
`

func (q *Queries) DeleteProjectRelationship(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProjectRelationship, id)
	return err
}

const deleteProjectRelationshipByPublicID = `-- name: DeleteProjectRelationshipByPublicID :exec
DELETE FROM relationships WHERE public_id = $1
`

func (q *Queries) DeleteProjectRelationshipByPublicID(ctx context.Context, publicID string) error {
	_, err := q.db.Exec(ctx, deleteProjectRelationshipByPublicID, publicID)
	return err
}

const deleteRelationshipSources = `-- name: DeleteRelationshipSources :exec
DELETE FROM relationship_sources WHERE relationship_id = $1
`

func (q *Queries) DeleteRelationshipSources(ctx context.Context, relationshipID int64) error {
	_, err := q.db.Exec(ctx, deleteRelationshipSources, relationshipID)
	return err
}

const deleteRelationshipsWithoutSources = `-- name: DeleteRelationshipsWithoutSources :exec
DELETE FROM relationships 
WHERE project_id = $1 
  AND id NOT IN (SELECT DISTINCT relationship_id FROM relationship_sources)
`

func (q *Queries) DeleteRelationshipsWithoutSources(ctx context.Context, projectID int64) error {
	_, err := q.db.Exec(ctx, deleteRelationshipsWithoutSources, projectID)
	return err
}

const findDuplicateRelationships = `-- name: FindDuplicateRelationships :many
SELECT r1.id as id1, r1.public_id as public_id1, r1.rank as rank1,
       r2.id as id2, r2.public_id as public_id2, r2.rank as rank2,
       r1.source_id, r1.target_id
FROM relationships r1
JOIN relationships r2 ON (
    (r1.source_id = r2.source_id AND r1.target_id = r2.target_id)
    OR (r1.source_id = r2.target_id AND r1.target_id = r2.source_id)
)
WHERE r1.id < r2.id AND r1.project_id = $1
`

type FindDuplicateRelationshipsRow struct {
	Id1       int64   `json:"id1"`
	PublicId1 string  `json:"public_id1"`
	Rank1     float64 `json:"rank1"`
	Id2       int64   `json:"id2"`
	PublicId2 string  `json:"public_id2"`
	Rank2     float64 `json:"rank2"`
	SourceID  int64   `json:"source_id"`
	TargetID  int64   `json:"target_id"`
}

func (q *Queries) FindDuplicateRelationships(ctx context.Context, projectID int64) ([]FindDuplicateRelationshipsRow, error) {
	rows, err := q.db.Query(ctx, findDuplicateRelationships, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindDuplicateRelationshipsRow{}
	for rows.Next() {
		var i FindDuplicateRelationshipsRow
		if err := rows.Scan(
			&i.Id1,
			&i.PublicId1,
			&i.Rank1,
			&i.Id2,
			&i.PublicId2,
			&i.Rank2,
			&i.SourceID,
			&i.TargetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRelationshipSourceDescriptions = `-- name: GetAllRelationshipSourceDescriptions :many
SELECT rs.id, rs.description, rs.text_unit_id
FROM relationship_sources rs
WHERE rs.relationship_id = $1
`

type GetAllRelationshipSourceDescriptionsRow struct {
	ID          int64  `json:"id"`
	Description string `json:"description"`
	TextUnitID  int64  `json:"text_unit_id"`
}

func (q *Queries) GetAllRelationshipSourceDescriptions(ctx context.Context, relationshipID int64) ([]GetAllRelationshipSourceDescriptionsRow, error) {
	rows, err := q.db.Query(ctx, getAllRelationshipSourceDescriptions, relationshipID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllRelationshipSourceDescriptionsRow{}
	for rows.Next() {
		var i GetAllRelationshipSourceDescriptionsRow
		if err := rows.Scan(&i.ID, &i.Description, &i.TextUnitID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMinProjectRelationships = `-- name: GetMinProjectRelationships :many
SELECT 
    r.id,
    r.public_id,
    r.rank,
    r.source_id,
    r.target_id,
    r.description,
    se.public_id as source_public_id,
    se.name as source_name,
    se.type as source_type,
    te.public_id as target_public_id,
    te.name as target_name,
    te.type as target_type
FROM relationships r
JOIN entities se ON r.source_id = se.id
JOIN entities te ON r.target_id = te.id
WHERE r.project_id = $1
`

type GetMinProjectRelationshipsRow struct {
	ID             int64   `json:"id"`
	PublicID       string  `json:"public_id"`
	Rank           float64 `json:"rank"`
	SourceID       int64   `json:"source_id"`
	TargetID       int64   `json:"target_id"`
	Description    string  `json:"description"`
	SourcePublicID string  `json:"source_public_id"`
	SourceName     string  `json:"source_name"`
	SourceType     string  `json:"source_type"`
	TargetPublicID string  `json:"target_public_id"`
	TargetName     string  `json:"target_name"`
	TargetType     string  `json:"target_type"`
}

func (q *Queries) GetMinProjectRelationships(ctx context.Context, projectID int64) ([]GetMinProjectRelationshipsRow, error) {
	rows, err := q.db.Query(ctx, getMinProjectRelationships, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMinProjectRelationshipsRow{}
	for rows.Next() {
		var i GetMinProjectRelationshipsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Rank,
			&i.SourceID,
			&i.TargetID,
			&i.Description,
			&i.SourcePublicID,
			&i.SourceName,
			&i.SourceType,
			&i.TargetPublicID,
			&i.TargetName,
			&i.TargetType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectRelationshipByEntityIDs = `-- name: GetProjectRelationshipByEntityIDs :one
SELECT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank
FROM relationships r
WHERE r.project_id = $1 AND ((r.source_id = $2 AND r.target_id = $3) OR (r.source_id = $3 AND r.target_id = $2))
`

type GetProjectRelationshipByEntityIDsParams struct {
	ProjectID int64 `json:"project_id"`
	SourceID  int64 `json:"source_id"`
	TargetID  int64 `json:"target_id"`
}

type GetProjectRelationshipByEntityIDsRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetProjectRelationshipByEntityIDs(ctx context.Context, arg GetProjectRelationshipByEntityIDsParams) (GetProjectRelationshipByEntityIDsRow, error) {
	row := q.db.QueryRow(ctx, getProjectRelationshipByEntityIDs, arg.ProjectID, arg.SourceID, arg.TargetID)
	var i GetProjectRelationshipByEntityIDsRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SourceID,
		&i.TargetID,
		&i.Description,
		&i.Rank,
	)
	return i, err
}

const getProjectRelationshipByEntityNames = `-- name: GetProjectRelationshipByEntityNames :one
SELECT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank
FROM relationships r
JOIN entities se ON r.source_id = se.id
JOIN entities te ON r.target_id = te.id
WHERE r.project_id = $1 AND ((se.name = $2 AND te.name = $3) OR (se.name = $3 AND te.name = $2))
`

type GetProjectRelationshipByEntityNamesParams struct {
	ProjectID int64  `json:"project_id"`
	Name      string `json:"name"`
	Name_2    string `json:"name_2"`
}

type GetProjectRelationshipByEntityNamesRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetProjectRelationshipByEntityNames(ctx context.Context, arg GetProjectRelationshipByEntityNamesParams) (GetProjectRelationshipByEntityNamesRow, error) {
	row := q.db.QueryRow(ctx, getProjectRelationshipByEntityNames, arg.ProjectID, arg.Name, arg.Name_2)
	var i GetProjectRelationshipByEntityNamesRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SourceID,
		&i.TargetID,
		&i.Description,
		&i.Rank,
	)
	return i, err
}

const getProjectRelationshipByID = `-- name: GetProjectRelationshipByID :one
SELECT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank FROM relationships r WHERE r.id = $1
`

type GetProjectRelationshipByIDRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetProjectRelationshipByID(ctx context.Context, id int64) (GetProjectRelationshipByIDRow, error) {
	row := q.db.QueryRow(ctx, getProjectRelationshipByID, id)
	var i GetProjectRelationshipByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SourceID,
		&i.TargetID,
		&i.Description,
		&i.Rank,
	)
	return i, err
}

const getProjectRelationshipByPublicID = `-- name: GetProjectRelationshipByPublicID :one
SELECT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank FROM relationships r WHERE r.public_id = $1
`

type GetProjectRelationshipByPublicIDRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetProjectRelationshipByPublicID(ctx context.Context, publicID string) (GetProjectRelationshipByPublicIDRow, error) {
	row := q.db.QueryRow(ctx, getProjectRelationshipByPublicID, publicID)
	var i GetProjectRelationshipByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.SourceID,
		&i.TargetID,
		&i.Description,
		&i.Rank,
	)
	return i, err
}

const getProjectRelationshipSourcesByPublicID = `-- name: GetProjectRelationshipSourcesByPublicID :many
SELECT ps.public_id, ps.description FROM relationship_sources ps
JOIN relationships pr ON ps.relationship_id = pr.id
WHERE pr.public_id = $1
`

type GetProjectRelationshipSourcesByPublicIDRow struct {
	PublicID    string `json:"public_id"`
	Description string `json:"description"`
}

func (q *Queries) GetProjectRelationshipSourcesByPublicID(ctx context.Context, publicID string) ([]GetProjectRelationshipSourcesByPublicIDRow, error) {
	rows, err := q.db.Query(ctx, getProjectRelationshipSourcesByPublicID, publicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectRelationshipSourcesByPublicIDRow{}
	for rows.Next() {
		var i GetProjectRelationshipSourcesByPublicIDRow
		if err := rows.Scan(&i.PublicID, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectRelationshipWithSourcesFromUnitID = `-- name: GetProjectRelationshipWithSourcesFromUnitID :many
SELECT pr.id, pr.public_id, pr.source_id, pr.target_id, pr.description, pr.rank, prs.id, prs.public_id, prs.text_unit_id, prs.relationship_id, prs.description
FROM relationships pr
JOIN relationship_sources prs 
    ON prs.relationship_id = pr.id
WHERE pr.id = (
    SELECT prs2.relationship_id
    FROM relationship_sources prs2
    WHERE prs2.text_unit_id = $1
)
`

type GetProjectRelationshipWithSourcesFromUnitIDRow struct {
	ID             int64   `json:"id"`
	PublicID       string  `json:"public_id"`
	SourceID       int64   `json:"source_id"`
	TargetID       int64   `json:"target_id"`
	Description    string  `json:"description"`
	Rank           float64 `json:"rank"`
	ID_2           int64   `json:"id_2"`
	PublicID_2     string  `json:"public_id_2"`
	TextUnitID     int64   `json:"text_unit_id"`
	RelationshipID int64   `json:"relationship_id"`
	Description_2  string  `json:"description_2"`
}

func (q *Queries) GetProjectRelationshipWithSourcesFromUnitID(ctx context.Context, textUnitID int64) ([]GetProjectRelationshipWithSourcesFromUnitIDRow, error) {
	rows, err := q.db.Query(ctx, getProjectRelationshipWithSourcesFromUnitID, textUnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectRelationshipWithSourcesFromUnitIDRow{}
	for rows.Next() {
		var i GetProjectRelationshipWithSourcesFromUnitIDRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceID,
			&i.TargetID,
			&i.Description,
			&i.Rank,
			&i.ID_2,
			&i.PublicID_2,
			&i.TextUnitID,
			&i.RelationshipID,
			&i.Description_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectRelationships = `-- name: GetProjectRelationships :many
SELECT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank FROM relationships r WHERE r.project_id = $1
`

type GetProjectRelationshipsRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetProjectRelationships(ctx context.Context, projectID int64) ([]GetProjectRelationshipsRow, error) {
	rows, err := q.db.Query(ctx, getProjectRelationships, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectRelationshipsRow{}
	for rows.Next() {
		var i GetProjectRelationshipsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceID,
			&i.TargetID,
			&i.Description,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectRelationshipsByIDs = `-- name: GetProjectRelationshipsByIDs :many
SELECT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank FROM relationships r WHERE r.id = ANY($1::bigint[])
`

type GetProjectRelationshipsByIDsRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetProjectRelationshipsByIDs(ctx context.Context, dollar_1 []int64) ([]GetProjectRelationshipsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getProjectRelationshipsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectRelationshipsByIDsRow{}
	for rows.Next() {
		var i GetProjectRelationshipsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceID,
			&i.TargetID,
			&i.Description,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationshipSourceDescriptionsForFiles = `-- name: GetRelationshipSourceDescriptionsForFiles :many
SELECT rs.description
FROM relationship_sources rs
JOIN text_units tu ON tu.id = rs.text_unit_id
WHERE rs.relationship_id = $1
  AND tu.project_file_id = ANY($2::bigint[])
`

type GetRelationshipSourceDescriptionsForFilesParams struct {
	RelationshipID int64   `json:"relationship_id"`
	Column2        []int64 `json:"column_2"`
}

func (q *Queries) GetRelationshipSourceDescriptionsForFiles(ctx context.Context, arg GetRelationshipSourceDescriptionsForFilesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getRelationshipSourceDescriptionsForFiles, arg.RelationshipID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var description string
		if err := rows.Scan(&description); err != nil {
			return nil, err
		}
		items = append(items, description)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationshipsWithSourcesFromFiles = `-- name: GetRelationshipsWithSourcesFromFiles :many
SELECT DISTINCT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank
FROM relationships r
JOIN relationship_sources rs ON rs.relationship_id = r.id
JOIN text_units tu ON tu.id = rs.text_unit_id
WHERE tu.project_file_id = ANY($1::bigint[])
  AND r.project_id = $2
`

type GetRelationshipsWithSourcesFromFilesParams struct {
	Column1   []int64 `json:"column_1"`
	ProjectID int64   `json:"project_id"`
}

type GetRelationshipsWithSourcesFromFilesRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetRelationshipsWithSourcesFromFiles(ctx context.Context, arg GetRelationshipsWithSourcesFromFilesParams) ([]GetRelationshipsWithSourcesFromFilesRow, error) {
	rows, err := q.db.Query(ctx, getRelationshipsWithSourcesFromFiles, arg.Column1, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelationshipsWithSourcesFromFilesRow{}
	for rows.Next() {
		var i GetRelationshipsWithSourcesFromFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceID,
			&i.TargetID,
			&i.Description,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationshipsWithSourcesFromUnits = `-- name: GetRelationshipsWithSourcesFromUnits :many
SELECT DISTINCT r.id, r.public_id, r.source_id, r.target_id, r.description, r.rank
FROM relationships r
JOIN relationship_sources rs ON rs.relationship_id = r.id
WHERE rs.text_unit_id = ANY($1::bigint[])
  AND r.project_id = $2
`

type GetRelationshipsWithSourcesFromUnitsParams struct {
	Column1   []int64 `json:"column_1"`
	ProjectID int64   `json:"project_id"`
}

type GetRelationshipsWithSourcesFromUnitsRow struct {
	ID          int64   `json:"id"`
	PublicID    string  `json:"public_id"`
	SourceID    int64   `json:"source_id"`
	TargetID    int64   `json:"target_id"`
	Description string  `json:"description"`
	Rank        float64 `json:"rank"`
}

func (q *Queries) GetRelationshipsWithSourcesFromUnits(ctx context.Context, arg GetRelationshipsWithSourcesFromUnitsParams) ([]GetRelationshipsWithSourcesFromUnitsRow, error) {
	rows, err := q.db.Query(ctx, getRelationshipsWithSourcesFromUnits, arg.Column1, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelationshipsWithSourcesFromUnitsRow{}
	for rows.Next() {
		var i GetRelationshipsWithSourcesFromUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.SourceID,
			&i.TargetID,
			&i.Description,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transferRelationshipSources = `-- name: TransferRelationshipSources :exec
UPDATE relationship_sources SET relationship_id = $2 WHERE relationship_id = $1
`

type TransferRelationshipSourcesParams struct {
	RelationshipID   int64 `json:"relationship_id"`
	RelationshipID_2 int64 `json:"relationship_id_2"`
}

func (q *Queries) TransferRelationshipSources(ctx context.Context, arg TransferRelationshipSourcesParams) error {
	_, err := q.db.Exec(ctx, transferRelationshipSources, arg.RelationshipID, arg.RelationshipID_2)
	return err
}

const updateProjectRelationship = `-- name: UpdateProjectRelationship :one
UPDATE relationships SET description = $2, rank = $3, embedding = $4, updated_at = NOW() WHERE public_id = $1 RETURNING id
`

type UpdateProjectRelationshipParams struct {
	PublicID    string          `json:"public_id"`
	Description string          `json:"description"`
	Rank        float64         `json:"rank"`
	Embedding   pgvector.Vector `json:"embedding"`
}

func (q *Queries) UpdateProjectRelationship(ctx context.Context, arg UpdateProjectRelationshipParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateProjectRelationship,
		arg.PublicID,
		arg.Description,
		arg.Rank,
		arg.Embedding,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateProjectRelationshipByID = `-- name: UpdateProjectRelationshipByID :one
UPDATE relationships SET description = $2, embedding = $3, updated_at = NOW() WHERE id = $1 RETURNING id
`

type UpdateProjectRelationshipByIDParams struct {
	ID          int64           `json:"id"`
	Description string          `json:"description"`
	Embedding   pgvector.Vector `json:"embedding"`
}

func (q *Queries) UpdateProjectRelationshipByID(ctx context.Context, arg UpdateProjectRelationshipByIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateProjectRelationshipByID, arg.ID, arg.Description, arg.Embedding)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateRelationshipRank = `-- name: UpdateRelationshipRank :exec
UPDATE relationships SET rank = $1, updated_at = NOW() WHERE id = $2
`

type UpdateRelationshipRankParams struct {
	Rank float64 `json:"rank"`
	ID   int64   `json:"id"`
}

func (q *Queries) UpdateRelationshipRank(ctx context.Context, arg UpdateRelationshipRankParams) error {
	_, err := q.db.Exec(ctx, updateRelationshipRank, arg.Rank, arg.ID)
	return err
}

const updateRelationshipSourceEntity = `-- name: UpdateRelationshipSourceEntity :exec
UPDATE relationships SET source_id = $2 WHERE source_id = $1 AND project_id = $3
`

type UpdateRelationshipSourceEntityParams struct {
	SourceID   int64 `json:"source_id"`
	SourceID_2 int64 `json:"source_id_2"`
	ProjectID  int64 `json:"project_id"`
}

func (q *Queries) UpdateRelationshipSourceEntity(ctx context.Context, arg UpdateRelationshipSourceEntityParams) error {
	_, err := q.db.Exec(ctx, updateRelationshipSourceEntity, arg.SourceID, arg.SourceID_2, arg.ProjectID)
	return err
}

const updateRelationshipTargetEntity = `-- name: UpdateRelationshipTargetEntity :exec
UPDATE relationships SET target_id = $2 WHERE target_id = $1 AND project_id = $3
`

type UpdateRelationshipTargetEntityParams struct {
	TargetID   int64 `json:"target_id"`
	TargetID_2 int64 `json:"target_id_2"`
	ProjectID  int64 `json:"project_id"`
}

func (q *Queries) UpdateRelationshipTargetEntity(ctx context.Context, arg UpdateRelationshipTargetEntityParams) error {
	_, err := q.db.Exec(ctx, updateRelationshipTargetEntity, arg.TargetID, arg.TargetID_2, arg.ProjectID)
	return err
}

const upsertProjectRelationships = `-- name: UpsertProjectRelationships :many
WITH input AS (
    SELECT
        u.public_id,
        ($2::bigint[])[u.ord]::bigint AS source_id,
        ($3::bigint[])[u.ord]::bigint AS target_id,
        ($4::float8[])[u.ord]::float8 AS rank,
        ($5::text[])[u.ord]::text AS description,
        ($6::vector[])[u.ord]::vector AS embedding
    FROM unnest($7::text[]) WITH ORDINALITY AS u(public_id, ord)
)
INSERT INTO relationships (public_id, project_id, source_id, target_id, rank, description, embedding)
SELECT public_id, $1::bigint, source_id, target_id, rank, description, embedding
FROM input
ON CONFLICT (public_id) DO UPDATE
SET project_id = EXCLUDED.project_id,
    source_id = EXCLUDED.source_id,
    target_id = EXCLUDED.target_id,
    rank = EXCLUDED.rank,
    description = EXCLUDED.description,
    embedding = EXCLUDED.embedding,
    updated_at = NOW()
RETURNING id, public_id
`

type UpsertProjectRelationshipsParams struct {
	ProjectID    int64             `json:"project_id"`
	SourceIds    []int64           `json:"source_ids"`
	TargetIds    []int64           `json:"target_ids"`
	Ranks        []float64         `json:"ranks"`
	Descriptions []string          `json:"descriptions"`
	Embeddings   []pgvector.Vector `json:"embeddings"`
	PublicIds    []string          `json:"public_ids"`
}

type UpsertProjectRelationshipsRow struct {
	ID       int64  `json:"id"`
	PublicID string `json:"public_id"`
}

func (q *Queries) UpsertProjectRelationships(ctx context.Context, arg UpsertProjectRelationshipsParams) ([]UpsertProjectRelationshipsRow, error) {
	rows, err := q.db.Query(ctx, upsertProjectRelationships,
		arg.ProjectID,
		arg.SourceIds,
		arg.TargetIds,
		arg.Ranks,
		arg.Descriptions,
		arg.Embeddings,
		arg.PublicIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UpsertProjectRelationshipsRow{}
	for rows.Next() {
		var i UpsertProjectRelationshipsRow
		if err := rows.Scan(&i.ID, &i.PublicID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRelationshipSources = `-- name: UpsertRelationshipSources :exec
WITH input AS (
    SELECT
        u.public_id,
        ($1::bigint[])[u.ord]::bigint AS relationship_id,
        ($2::bigint[])[u.ord]::bigint AS text_unit_id,
        ($3::text[])[u.ord]::text AS description,
        ($4::vector[])[u.ord]::vector AS embedding
    FROM unnest($5::text[]) WITH ORDINALITY AS u(public_id, ord)
)
INSERT INTO relationship_sources (public_id, relationship_id, text_unit_id, description, embedding)
SELECT public_id, relationship_id, text_unit_id, description, embedding
FROM input
ON CONFLICT (public_id) DO UPDATE
SET relationship_id = EXCLUDED.relationship_id,
    text_unit_id = EXCLUDED.text_unit_id,
    description = EXCLUDED.description,
    embedding = EXCLUDED.embedding,
    updated_at = NOW()
`

type UpsertRelationshipSourcesParams struct {
	RelationshipIds []int64           `json:"relationship_ids"`
	TextUnitIds     []int64           `json:"text_unit_ids"`
	Descriptions    []string          `json:"descriptions"`
	Embeddings      []pgvector.Vector `json:"embeddings"`
	PublicIds       []string          `json:"public_ids"`
}

func (q *Queries) UpsertRelationshipSources(ctx context.Context, arg UpsertRelationshipSourcesParams) error {
	_, err := q.db.Exec(ctx, upsertRelationshipSources,
		arg.RelationshipIds,
		arg.TextUnitIds,
		arg.Descriptions,
		arg.Embeddings,
		arg.PublicIds,
	)
	return err
}
