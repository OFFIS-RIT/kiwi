// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: entities.sql

package db

import (
	"context"

	"github.com/pgvector/pgvector-go"
)

const addProjectEntity = `-- name: AddProjectEntity :one
INSERT INTO entities (public_id, project_id, name, description, type, embedding)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (public_id) DO UPDATE
SET project_id = EXCLUDED.project_id,
    name = EXCLUDED.name,
    description = EXCLUDED.description,
    type = EXCLUDED.type,
    embedding = EXCLUDED.embedding,
    updated_at = NOW()
RETURNING id
`

type AddProjectEntityParams struct {
	PublicID    string          `json:"public_id"`
	ProjectID   int64           `json:"project_id"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Type        string          `json:"type"`
	Embedding   pgvector.Vector `json:"embedding"`
}

func (q *Queries) AddProjectEntity(ctx context.Context, arg AddProjectEntityParams) (int64, error) {
	row := q.db.QueryRow(ctx, addProjectEntity,
		arg.PublicID,
		arg.ProjectID,
		arg.Name,
		arg.Description,
		arg.Type,
		arg.Embedding,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addProjectEntitySource = `-- name: AddProjectEntitySource :one
INSERT INTO entity_sources (public_id, entity_id, text_unit_id, description, embedding)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (public_id) DO UPDATE
SET entity_id = EXCLUDED.entity_id,
    text_unit_id = EXCLUDED.text_unit_id,
    description = EXCLUDED.description,
    embedding = EXCLUDED.embedding,
    updated_at = NOW()
RETURNING id
`

type AddProjectEntitySourceParams struct {
	PublicID    string          `json:"public_id"`
	EntityID    int64           `json:"entity_id"`
	TextUnitID  int64           `json:"text_unit_id"`
	Description string          `json:"description"`
	Embedding   pgvector.Vector `json:"embedding"`
}

func (q *Queries) AddProjectEntitySource(ctx context.Context, arg AddProjectEntitySourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, addProjectEntitySource,
		arg.PublicID,
		arg.EntityID,
		arg.TextUnitID,
		arg.Description,
		arg.Embedding,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const countEntitySources = `-- name: CountEntitySources :one
SELECT COUNT(*)::int FROM entity_sources WHERE entity_id = $1
`

func (q *Queries) CountEntitySources(ctx context.Context, entityID int64) (int32, error) {
	row := q.db.QueryRow(ctx, countEntitySources, entityID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countEntitySourcesFromUnits = `-- name: CountEntitySourcesFromUnits :one
SELECT COUNT(*)::int 
FROM entity_sources es
WHERE es.entity_id = $1 
  AND es.text_unit_id = ANY($2::bigint[])
`

type CountEntitySourcesFromUnitsParams struct {
	EntityID int64   `json:"entity_id"`
	Column2  []int64 `json:"column_2"`
}

func (q *Queries) CountEntitySourcesFromUnits(ctx context.Context, arg CountEntitySourcesFromUnitsParams) (int32, error) {
	row := q.db.QueryRow(ctx, countEntitySourcesFromUnits, arg.EntityID, arg.Column2)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteEntitiesWithoutSources = `-- name: DeleteEntitiesWithoutSources :exec
DELETE FROM entities 
WHERE project_id = $1 
  AND id NOT IN (SELECT DISTINCT entity_id FROM entity_sources)
`

func (q *Queries) DeleteEntitiesWithoutSources(ctx context.Context, projectID int64) error {
	_, err := q.db.Exec(ctx, deleteEntitiesWithoutSources, projectID)
	return err
}

const deleteEntitySources = `-- name: DeleteEntitySources :exec
DELETE FROM entity_sources WHERE entity_id = $1
`

func (q *Queries) DeleteEntitySources(ctx context.Context, entityID int64) error {
	_, err := q.db.Exec(ctx, deleteEntitySources, entityID)
	return err
}

const deleteProjectEntity = `-- name: DeleteProjectEntity :exec
DELETE FROM entities WHERE id = $1
`

func (q *Queries) DeleteProjectEntity(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProjectEntity, id)
	return err
}

const deleteProjectEntityByPublicID = `-- name: DeleteProjectEntityByPublicID :exec
DELETE FROM entities WHERE public_id = $1
`

func (q *Queries) DeleteProjectEntityByPublicID(ctx context.Context, publicID string) error {
	_, err := q.db.Exec(ctx, deleteProjectEntityByPublicID, publicID)
	return err
}

const findEntitiesWithSimilarNames = `-- name: FindEntitiesWithSimilarNames :many
SELECT e1.id as id1, e1.public_id as public_id1, e1.name as name1, e1.type as type1,
       e2.id as id2, e2.public_id as public_id2, e2.name as name2, e2.type as type2
FROM entities e1
JOIN entities e2 ON similarity(e1.name, e2.name) > 0.5 AND e1.type = e2.type AND e2.project_id = $1
WHERE e1.id < e2.id AND e1.project_id = $1 AND e1.type NOT IN ('FACT', 'FILE')
`

type FindEntitiesWithSimilarNamesRow struct {
	Id1       int64  `json:"id1"`
	PublicId1 string `json:"public_id1"`
	Name1     string `json:"name1"`
	Type1     string `json:"type1"`
	Id2       int64  `json:"id2"`
	PublicId2 string `json:"public_id2"`
	Name2     string `json:"name2"`
	Type2     string `json:"type2"`
}

func (q *Queries) FindEntitiesWithSimilarNames(ctx context.Context, projectID int64) ([]FindEntitiesWithSimilarNamesRow, error) {
	rows, err := q.db.Query(ctx, findEntitiesWithSimilarNames, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindEntitiesWithSimilarNamesRow{}
	for rows.Next() {
		var i FindEntitiesWithSimilarNamesRow
		if err := rows.Scan(
			&i.Id1,
			&i.PublicId1,
			&i.Name1,
			&i.Type1,
			&i.Id2,
			&i.PublicId2,
			&i.Name2,
			&i.Type2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllEntitySourceDescriptions = `-- name: GetAllEntitySourceDescriptions :many
SELECT es.id, es.description, es.text_unit_id
FROM entity_sources es
WHERE es.entity_id = $1
`

type GetAllEntitySourceDescriptionsRow struct {
	ID          int64  `json:"id"`
	Description string `json:"description"`
	TextUnitID  int64  `json:"text_unit_id"`
}

func (q *Queries) GetAllEntitySourceDescriptions(ctx context.Context, entityID int64) ([]GetAllEntitySourceDescriptionsRow, error) {
	rows, err := q.db.Query(ctx, getAllEntitySourceDescriptions, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllEntitySourceDescriptionsRow{}
	for rows.Next() {
		var i GetAllEntitySourceDescriptionsRow
		if err := rows.Scan(&i.ID, &i.Description, &i.TextUnitID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesWithSourcesFromFiles = `-- name: GetEntitiesWithSourcesFromFiles :many
SELECT DISTINCT e.id, e.public_id, e.name, e.type, e.description
FROM entities e
JOIN entity_sources es ON es.entity_id = e.id
JOIN text_units tu ON tu.id = es.text_unit_id
WHERE tu.project_file_id = ANY($1::bigint[])
  AND e.project_id = $2
`

type GetEntitiesWithSourcesFromFilesParams struct {
	Column1   []int64 `json:"column_1"`
	ProjectID int64   `json:"project_id"`
}

type GetEntitiesWithSourcesFromFilesRow struct {
	ID          int64  `json:"id"`
	PublicID    string `json:"public_id"`
	Name        string `json:"name"`
	Type        string `json:"type"`
	Description string `json:"description"`
}

func (q *Queries) GetEntitiesWithSourcesFromFiles(ctx context.Context, arg GetEntitiesWithSourcesFromFilesParams) ([]GetEntitiesWithSourcesFromFilesRow, error) {
	rows, err := q.db.Query(ctx, getEntitiesWithSourcesFromFiles, arg.Column1, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntitiesWithSourcesFromFilesRow{}
	for rows.Next() {
		var i GetEntitiesWithSourcesFromFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Type,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitiesWithSourcesFromUnits = `-- name: GetEntitiesWithSourcesFromUnits :many
SELECT DISTINCT e.id, e.public_id, e.name, e.type, e.description
FROM entities e
JOIN entity_sources es ON es.entity_id = e.id
WHERE es.text_unit_id = ANY($1::bigint[])
  AND e.project_id = $2
`

type GetEntitiesWithSourcesFromUnitsParams struct {
	Column1   []int64 `json:"column_1"`
	ProjectID int64   `json:"project_id"`
}

type GetEntitiesWithSourcesFromUnitsRow struct {
	ID          int64  `json:"id"`
	PublicID    string `json:"public_id"`
	Name        string `json:"name"`
	Type        string `json:"type"`
	Description string `json:"description"`
}

func (q *Queries) GetEntitiesWithSourcesFromUnits(ctx context.Context, arg GetEntitiesWithSourcesFromUnitsParams) ([]GetEntitiesWithSourcesFromUnitsRow, error) {
	rows, err := q.db.Query(ctx, getEntitiesWithSourcesFromUnits, arg.Column1, arg.ProjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntitiesWithSourcesFromUnitsRow{}
	for rows.Next() {
		var i GetEntitiesWithSourcesFromUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Type,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityIDsByPublicIDs = `-- name: GetEntityIDsByPublicIDs :many
SELECT e.id, e.public_id
FROM entities e
WHERE e.project_id = $1 AND e.public_id = ANY($2::text[])
`

type GetEntityIDsByPublicIDsParams struct {
	ProjectID int64    `json:"project_id"`
	PublicIds []string `json:"public_ids"`
}

type GetEntityIDsByPublicIDsRow struct {
	ID       int64  `json:"id"`
	PublicID string `json:"public_id"`
}

func (q *Queries) GetEntityIDsByPublicIDs(ctx context.Context, arg GetEntityIDsByPublicIDsParams) ([]GetEntityIDsByPublicIDsRow, error) {
	rows, err := q.db.Query(ctx, getEntityIDsByPublicIDs, arg.ProjectID, arg.PublicIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntityIDsByPublicIDsRow{}
	for rows.Next() {
		var i GetEntityIDsByPublicIDsRow
		if err := rows.Scan(&i.ID, &i.PublicID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitySourceDescriptionsBatch = `-- name: GetEntitySourceDescriptionsBatch :many
SELECT es.id, es.description
FROM entity_sources es
WHERE es.entity_id = $1
  AND es.id > $2
ORDER BY es.id
LIMIT $3
`

type GetEntitySourceDescriptionsBatchParams struct {
	EntityID int64 `json:"entity_id"`
	ID       int64 `json:"id"`
	Limit    int32 `json:"limit"`
}

type GetEntitySourceDescriptionsBatchRow struct {
	ID          int64  `json:"id"`
	Description string `json:"description"`
}

func (q *Queries) GetEntitySourceDescriptionsBatch(ctx context.Context, arg GetEntitySourceDescriptionsBatchParams) ([]GetEntitySourceDescriptionsBatchRow, error) {
	rows, err := q.db.Query(ctx, getEntitySourceDescriptionsBatch, arg.EntityID, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntitySourceDescriptionsBatchRow{}
	for rows.Next() {
		var i GetEntitySourceDescriptionsBatchRow
		if err := rows.Scan(&i.ID, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitySourceDescriptionsForFiles = `-- name: GetEntitySourceDescriptionsForFiles :many
SELECT es.description
FROM entity_sources es
JOIN text_units tu ON tu.id = es.text_unit_id
WHERE es.entity_id = $1
  AND tu.project_file_id = ANY($2::bigint[])
`

type GetEntitySourceDescriptionsForFilesParams struct {
	EntityID int64   `json:"entity_id"`
	Column2  []int64 `json:"column_2"`
}

func (q *Queries) GetEntitySourceDescriptionsForFiles(ctx context.Context, arg GetEntitySourceDescriptionsForFilesParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getEntitySourceDescriptionsForFiles, arg.EntityID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var description string
		if err := rows.Scan(&description); err != nil {
			return nil, err
		}
		items = append(items, description)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntitySourceDescriptionsForFilesBatch = `-- name: GetEntitySourceDescriptionsForFilesBatch :many
SELECT es.id, es.description
FROM entity_sources es
JOIN text_units tu ON tu.id = es.text_unit_id
WHERE es.entity_id = $1
  AND tu.project_file_id = ANY($2::bigint[])
  AND es.id > $3
ORDER BY es.id
LIMIT $4
`

type GetEntitySourceDescriptionsForFilesBatchParams struct {
	EntityID int64   `json:"entity_id"`
	Column2  []int64 `json:"column_2"`
	ID       int64   `json:"id"`
	Limit    int32   `json:"limit"`
}

type GetEntitySourceDescriptionsForFilesBatchRow struct {
	ID          int64  `json:"id"`
	Description string `json:"description"`
}

func (q *Queries) GetEntitySourceDescriptionsForFilesBatch(ctx context.Context, arg GetEntitySourceDescriptionsForFilesBatchParams) ([]GetEntitySourceDescriptionsForFilesBatchRow, error) {
	rows, err := q.db.Query(ctx, getEntitySourceDescriptionsForFilesBatch,
		arg.EntityID,
		arg.Column2,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntitySourceDescriptionsForFilesBatchRow{}
	for rows.Next() {
		var i GetEntitySourceDescriptionsForFilesBatchRow
		if err := rows.Scan(&i.ID, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityTypes = `-- name: GetEntityTypes :many
SELECT e.type, COUNT(*) as count
FROM entities e
WHERE e.project_id = $1
GROUP BY e.type
ORDER BY count DESC
`

type GetEntityTypesRow struct {
	Type  string `json:"type"`
	Count int64  `json:"count"`
}

func (q *Queries) GetEntityTypes(ctx context.Context, projectID int64) ([]GetEntityTypesRow, error) {
	rows, err := q.db.Query(ctx, getEntityTypes, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEntityTypesRow{}
	for rows.Next() {
		var i GetEntityTypesRow
		if err := rows.Scan(&i.Type, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMinProjectEntities = `-- name: GetMinProjectEntities :many
SELECT id, public_id, name, type, description
FROM entities 
WHERE project_id = $1
`

type GetMinProjectEntitiesRow struct {
	ID          int64  `json:"id"`
	PublicID    string `json:"public_id"`
	Name        string `json:"name"`
	Type        string `json:"type"`
	Description string `json:"description"`
}

func (q *Queries) GetMinProjectEntities(ctx context.Context, projectID int64) ([]GetMinProjectEntitiesRow, error) {
	rows, err := q.db.Query(ctx, getMinProjectEntities, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMinProjectEntitiesRow{}
	for rows.Next() {
		var i GetMinProjectEntitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Type,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectEntities = `-- name: GetProjectEntities :many
SELECT e.id, e.public_id, e.name, e.description, e.type FROM entities e WHERE e.project_id = $1
`

type GetProjectEntitiesRow struct {
	ID          int64  `json:"id"`
	PublicID    string `json:"public_id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Type        string `json:"type"`
}

func (q *Queries) GetProjectEntities(ctx context.Context, projectID int64) ([]GetProjectEntitiesRow, error) {
	rows, err := q.db.Query(ctx, getProjectEntities, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectEntitiesRow{}
	for rows.Next() {
		var i GetProjectEntitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Description,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectEntitiesByIDs = `-- name: GetProjectEntitiesByIDs :many
SELECT e.id, e.public_id, e.name, e.description, e.type FROM entities e WHERE e.id = ANY($1::bigint[])
`

type GetProjectEntitiesByIDsRow struct {
	ID          int64  `json:"id"`
	PublicID    string `json:"public_id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Type        string `json:"type"`
}

func (q *Queries) GetProjectEntitiesByIDs(ctx context.Context, dollar_1 []int64) ([]GetProjectEntitiesByIDsRow, error) {
	rows, err := q.db.Query(ctx, getProjectEntitiesByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectEntitiesByIDsRow{}
	for rows.Next() {
		var i GetProjectEntitiesByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Description,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectEntitiesByNames = `-- name: GetProjectEntitiesByNames :many
SELECT e.id, e.public_id, e.name, e.description, e.type FROM entities e WHERE e.project_id = $1 AND e.name = ANY($2::text[])
`

type GetProjectEntitiesByNamesParams struct {
	ProjectID int64    `json:"project_id"`
	Column2   []string `json:"column_2"`
}

type GetProjectEntitiesByNamesRow struct {
	ID          int64  `json:"id"`
	PublicID    string `json:"public_id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Type        string `json:"type"`
}

func (q *Queries) GetProjectEntitiesByNames(ctx context.Context, arg GetProjectEntitiesByNamesParams) ([]GetProjectEntitiesByNamesRow, error) {
	rows, err := q.db.Query(ctx, getProjectEntitiesByNames, arg.ProjectID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectEntitiesByNamesRow{}
	for rows.Next() {
		var i GetProjectEntitiesByNamesRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Description,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectEntityByID = `-- name: GetProjectEntityByID :one
SELECT e.id, e.public_id, e.name, e.description, e.type FROM entities e WHERE e.id = $1
`

type GetProjectEntityByIDRow struct {
	ID          int64  `json:"id"`
	PublicID    string `json:"public_id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Type        string `json:"type"`
}

func (q *Queries) GetProjectEntityByID(ctx context.Context, id int64) (GetProjectEntityByIDRow, error) {
	row := q.db.QueryRow(ctx, getProjectEntityByID, id)
	var i GetProjectEntityByIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.Description,
		&i.Type,
	)
	return i, err
}

const getProjectEntityByName = `-- name: GetProjectEntityByName :one
SELECT e.id, e.public_id, e.name, e.description, e.type FROM entities e WHERE e.project_id = $1 AND e.name = $2
`

type GetProjectEntityByNameParams struct {
	ProjectID int64  `json:"project_id"`
	Name      string `json:"name"`
}

type GetProjectEntityByNameRow struct {
	ID          int64  `json:"id"`
	PublicID    string `json:"public_id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Type        string `json:"type"`
}

func (q *Queries) GetProjectEntityByName(ctx context.Context, arg GetProjectEntityByNameParams) (GetProjectEntityByNameRow, error) {
	row := q.db.QueryRow(ctx, getProjectEntityByName, arg.ProjectID, arg.Name)
	var i GetProjectEntityByNameRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.Description,
		&i.Type,
	)
	return i, err
}

const getProjectEntityByNameSimilarity = `-- name: GetProjectEntityByNameSimilarity :one
SELECT e.id, e.public_id, e.name, e.description, e.type FROM entities e
WHERE e.project_id = $1
ORDER BY similarity(e.name, $2) DESC
LIMIT 1
`

type GetProjectEntityByNameSimilarityParams struct {
	ProjectID  int64       `json:"project_id"`
	Similarity interface{} `json:"similarity"`
}

type GetProjectEntityByNameSimilarityRow struct {
	ID          int64  `json:"id"`
	PublicID    string `json:"public_id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Type        string `json:"type"`
}

func (q *Queries) GetProjectEntityByNameSimilarity(ctx context.Context, arg GetProjectEntityByNameSimilarityParams) (GetProjectEntityByNameSimilarityRow, error) {
	row := q.db.QueryRow(ctx, getProjectEntityByNameSimilarity, arg.ProjectID, arg.Similarity)
	var i GetProjectEntityByNameSimilarityRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.Description,
		&i.Type,
	)
	return i, err
}

const getProjectEntityByPublicID = `-- name: GetProjectEntityByPublicID :one
SELECT e.id, e.public_id, e.name, e.description, e.type FROM entities e WHERE e.public_id = $1
`

type GetProjectEntityByPublicIDRow struct {
	ID          int64  `json:"id"`
	PublicID    string `json:"public_id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Type        string `json:"type"`
}

func (q *Queries) GetProjectEntityByPublicID(ctx context.Context, publicID string) (GetProjectEntityByPublicIDRow, error) {
	row := q.db.QueryRow(ctx, getProjectEntityByPublicID, publicID)
	var i GetProjectEntityByPublicIDRow
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.Description,
		&i.Type,
	)
	return i, err
}

const getProjectEntityNames = `-- name: GetProjectEntityNames :many
SELECT DISTINCT e.name FROM entities e WHERE e.project_id = $1
`

func (q *Queries) GetProjectEntityNames(ctx context.Context, projectID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getProjectEntityNames, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectEntitySourcesByPublicID = `-- name: GetProjectEntitySourcesByPublicID :many
SELECT ps.public_id, ps.description FROM entity_sources ps
JOIN entities pe ON ps.entity_id = pe.id
WHERE pe.public_id = $1
`

type GetProjectEntitySourcesByPublicIDRow struct {
	PublicID    string `json:"public_id"`
	Description string `json:"description"`
}

func (q *Queries) GetProjectEntitySourcesByPublicID(ctx context.Context, publicID string) ([]GetProjectEntitySourcesByPublicIDRow, error) {
	rows, err := q.db.Query(ctx, getProjectEntitySourcesByPublicID, publicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectEntitySourcesByPublicIDRow{}
	for rows.Next() {
		var i GetProjectEntitySourcesByPublicIDRow
		if err := rows.Scan(&i.PublicID, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectEntityWithSourcesFromUnitID = `-- name: GetProjectEntityWithSourcesFromUnitID :many
SELECT  pe.id, pe.public_id, pe.name, pe.description, pe.type, pes.id, pes.public_id, pes.text_unit_id, pes.entity_id, pes.description
FROM entities pe
JOIN entity_sources pes 
    ON pes.entity_id = pe.id
WHERE pe.id = (
    SELECT pes2.entity_id
    FROM entity_sources pes2
    WHERE pes2.text_unit_id = $1
)
`

type GetProjectEntityWithSourcesFromUnitIDRow struct {
	ID            int64  `json:"id"`
	PublicID      string `json:"public_id"`
	Name          string `json:"name"`
	Description   string `json:"description"`
	Type          string `json:"type"`
	ID_2          int64  `json:"id_2"`
	PublicID_2    string `json:"public_id_2"`
	TextUnitID    int64  `json:"text_unit_id"`
	EntityID      int64  `json:"entity_id"`
	Description_2 string `json:"description_2"`
}

func (q *Queries) GetProjectEntityWithSourcesFromUnitID(ctx context.Context, textUnitID int64) ([]GetProjectEntityWithSourcesFromUnitIDRow, error) {
	rows, err := q.db.Query(ctx, getProjectEntityWithSourcesFromUnitID, textUnitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProjectEntityWithSourcesFromUnitIDRow{}
	for rows.Next() {
		var i GetProjectEntityWithSourcesFromUnitIDRow
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.Description,
			&i.Type,
			&i.ID_2,
			&i.PublicID_2,
			&i.TextUnitID,
			&i.EntityID,
			&i.Description_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEntitiesByType = `-- name: SearchEntitiesByType :many
SELECT e.id, e.name, e.type, e.description
FROM entities e
WHERE e.project_id = $1 AND e.type = $2
ORDER BY e.embedding <=> $3
LIMIT $4
`

type SearchEntitiesByTypeParams struct {
	ProjectID int64           `json:"project_id"`
	Type      string          `json:"type"`
	Embedding pgvector.Vector `json:"embedding"`
	Limit     int32           `json:"limit"`
}

type SearchEntitiesByTypeRow struct {
	ID          int64  `json:"id"`
	Name        string `json:"name"`
	Type        string `json:"type"`
	Description string `json:"description"`
}

func (q *Queries) SearchEntitiesByType(ctx context.Context, arg SearchEntitiesByTypeParams) ([]SearchEntitiesByTypeRow, error) {
	rows, err := q.db.Query(ctx, searchEntitiesByType,
		arg.ProjectID,
		arg.Type,
		arg.Embedding,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchEntitiesByTypeRow{}
	for rows.Next() {
		var i SearchEntitiesByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transferEntitySources = `-- name: TransferEntitySources :exec
UPDATE entity_sources SET entity_id = $2 WHERE entity_id = $1
`

type TransferEntitySourcesParams struct {
	EntityID   int64 `json:"entity_id"`
	EntityID_2 int64 `json:"entity_id_2"`
}

func (q *Queries) TransferEntitySources(ctx context.Context, arg TransferEntitySourcesParams) error {
	_, err := q.db.Exec(ctx, transferEntitySources, arg.EntityID, arg.EntityID_2)
	return err
}

const updateEntityName = `-- name: UpdateEntityName :exec
UPDATE entities SET name = $2, updated_at = NOW() WHERE id = $1
`

type UpdateEntityNameParams struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpdateEntityName(ctx context.Context, arg UpdateEntityNameParams) error {
	_, err := q.db.Exec(ctx, updateEntityName, arg.ID, arg.Name)
	return err
}

const updateProjectEntitiesByIDs = `-- name: UpdateProjectEntitiesByIDs :exec
WITH input AS (
    SELECT
        u.id,
        ($1::text[])[u.ord]::text AS description,
        ($2::vector[])[u.ord]::vector AS embedding
    FROM unnest($3::bigint[]) WITH ORDINALITY AS u(id, ord)
)
UPDATE entities e
SET description = input.description,
    embedding = input.embedding,
    updated_at = NOW()
FROM input
WHERE e.id = input.id
`

type UpdateProjectEntitiesByIDsParams struct {
	Descriptions []string          `json:"descriptions"`
	Embeddings   []pgvector.Vector `json:"embeddings"`
	Ids          []int64           `json:"ids"`
}

func (q *Queries) UpdateProjectEntitiesByIDs(ctx context.Context, arg UpdateProjectEntitiesByIDsParams) error {
	_, err := q.db.Exec(ctx, updateProjectEntitiesByIDs, arg.Descriptions, arg.Embeddings, arg.Ids)
	return err
}

const updateProjectEntity = `-- name: UpdateProjectEntity :one
UPDATE entities SET description = $2, embedding = $3, updated_at = NOW() WHERE public_id = $1 RETURNING id
`

type UpdateProjectEntityParams struct {
	PublicID    string          `json:"public_id"`
	Description string          `json:"description"`
	Embedding   pgvector.Vector `json:"embedding"`
}

func (q *Queries) UpdateProjectEntity(ctx context.Context, arg UpdateProjectEntityParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateProjectEntity, arg.PublicID, arg.Description, arg.Embedding)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateProjectEntityByID = `-- name: UpdateProjectEntityByID :one
UPDATE entities SET description = $2, embedding = $3, updated_at = NOW() WHERE id = $1 RETURNING id
`

type UpdateProjectEntityByIDParams struct {
	ID          int64           `json:"id"`
	Description string          `json:"description"`
	Embedding   pgvector.Vector `json:"embedding"`
}

func (q *Queries) UpdateProjectEntityByID(ctx context.Context, arg UpdateProjectEntityByIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateProjectEntityByID, arg.ID, arg.Description, arg.Embedding)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const upsertEntitySources = `-- name: UpsertEntitySources :exec
WITH input AS (
    SELECT
        u.public_id,
        ($1::bigint[])[u.ord]::bigint AS entity_id,
        ($2::bigint[])[u.ord]::bigint AS text_unit_id,
        ($3::text[])[u.ord]::text AS description,
        ($4::vector[])[u.ord]::vector AS embedding
    FROM unnest($5::text[]) WITH ORDINALITY AS u(public_id, ord)
)
INSERT INTO entity_sources (public_id, entity_id, text_unit_id, description, embedding)
SELECT public_id, entity_id, text_unit_id, description, embedding
FROM input
ON CONFLICT (public_id) DO UPDATE
SET entity_id = EXCLUDED.entity_id,
    text_unit_id = EXCLUDED.text_unit_id,
    description = EXCLUDED.description,
    embedding = EXCLUDED.embedding,
    updated_at = NOW()
`

type UpsertEntitySourcesParams struct {
	EntityIds    []int64           `json:"entity_ids"`
	TextUnitIds  []int64           `json:"text_unit_ids"`
	Descriptions []string          `json:"descriptions"`
	Embeddings   []pgvector.Vector `json:"embeddings"`
	PublicIds    []string          `json:"public_ids"`
}

func (q *Queries) UpsertEntitySources(ctx context.Context, arg UpsertEntitySourcesParams) error {
	_, err := q.db.Exec(ctx, upsertEntitySources,
		arg.EntityIds,
		arg.TextUnitIds,
		arg.Descriptions,
		arg.Embeddings,
		arg.PublicIds,
	)
	return err
}

const upsertProjectEntities = `-- name: UpsertProjectEntities :many
WITH input AS (
    SELECT
        u.public_id,
        ($2::text[])[u.ord]::text AS name,
        ($3::text[])[u.ord]::text AS description,
        ($4::text[])[u.ord]::text AS type,
        ($5::vector[])[u.ord]::vector AS embedding
    FROM unnest($6::text[]) WITH ORDINALITY AS u(public_id, ord)
)
INSERT INTO entities (public_id, project_id, name, description, type, embedding)
SELECT public_id, $1::bigint, name, description, type, embedding
FROM input
ON CONFLICT (public_id) DO UPDATE
SET project_id = EXCLUDED.project_id,
    name = EXCLUDED.name,
    description = EXCLUDED.description,
    type = EXCLUDED.type,
    embedding = EXCLUDED.embedding,
    updated_at = NOW()
RETURNING id, public_id
`

type UpsertProjectEntitiesParams struct {
	ProjectID    int64             `json:"project_id"`
	Names        []string          `json:"names"`
	Descriptions []string          `json:"descriptions"`
	Types        []string          `json:"types"`
	Embeddings   []pgvector.Vector `json:"embeddings"`
	PublicIds    []string          `json:"public_ids"`
}

type UpsertProjectEntitiesRow struct {
	ID       int64  `json:"id"`
	PublicID string `json:"public_id"`
}

func (q *Queries) UpsertProjectEntities(ctx context.Context, arg UpsertProjectEntitiesParams) ([]UpsertProjectEntitiesRow, error) {
	rows, err := q.db.Query(ctx, upsertProjectEntities,
		arg.ProjectID,
		arg.Names,
		arg.Descriptions,
		arg.Types,
		arg.Embeddings,
		arg.PublicIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UpsertProjectEntitiesRow{}
	for rows.Next() {
		var i UpsertProjectEntitiesRow
		if err := rows.Scan(&i.ID, &i.PublicID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
